{
  "version": "5.3.1",
  "items": [
  {
    "alias": "browser",
    "description": "",
    "extends": "{webdriver_extensions.ExtendedWebDriver}",
    "fileName": "browser",
    "name": "ProtractorBrowser",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 109,
        "typeExpression": "webdriver.WebDriver",
        "type": {
          "type": "NameExpression",
          "name": "webdriver.WebDriver"
        },
        "typeList": [
          "webdriver.WebDriver"
        ],
        "name": "webdriver",
        "paramString": "[webdriver.WebDriver](webdriver.WebDriver)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "A base URL to run get requests against.",
        "startingLine": 110,
        "typeExpression": "string=",
        "type": {
          "type": "NameExpression",
          "name": "string",
          "optional": true
        },
        "typeList": [
          "string"
        ],
        "optional": true,
        "name": "opt_baseUrl",
        "paramString": "string="
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Selector element that has an ng-app in scope.",
        "startingLine": 111,
        "typeExpression": "string|webdriver.promise.Promise<string>=",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "webdriver.promise.Promise"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "string"
                }
              ],
              "optional": true
            }
          ]
        },
        "typeList": [
          "string",
          "webdriver.promise.Promise.<string>="
        ],
        "name": "opt_rootElement",
        "paramString": "string&#124;webdriver.promise.Promise&lt;string&gt;="
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Whether Protractor should stop tracking outstanding $timeouts.",
        "startingLine": 113,
        "typeExpression": "boolean=",
        "type": {
          "type": "NameExpression",
          "name": "boolean",
          "optional": true
        },
        "typeList": [
          "boolean"
        ],
        "optional": true,
        "name": "opt_untrackOutstandingTimeouts",
        "paramString": "boolean="
      }
    ],
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Set the css selector for an element on which to find Angular. This is usually\n&#39;body&#39; but if your ng-app is on a subsection of the page it may be\na subelement.</p>\n<p>The change will be made within WebDriver&#39;s control flow, so that commands after\nthis method is called use the new app root. Pass nothing to get a promise that\nresolves to the value of the selector.</p>\n",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.angularAppRoot",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The new selector.",
        "startingLine": 225,
        "typeExpression": "string|webdriver.promise.Promise<string>",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "webdriver.promise.Promise"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "string"
                }
              ]
            }
          ]
        },
        "typeList": [
          "string",
          "webdriver.promise.Promise.<string>"
        ],
        "name": "value",
        "paramString": "string&#124;webdriver.promise.Promise&lt;string&gt;"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that resolves with the value of the selector.",
      "startingLine": 226
    },
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>If set to false, Protractor will not wait for Angular $http and $timeout\ntasks to complete before interacting with the browser. This can cause\nflaky tests, but should be used if, for instance, your app continuously\npolls an API with $timeout.</p>\n<p>Call waitForAngularEnabled() without passing a value to read the current\nstate without changing it.</p>\n",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.waitForAngularEnabled",
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Get the processed configuration object that is currently being run. This\nwill contain the specs and capabilities properties of the current runner\ninstance.</p>\n<p>Set by the runner.</p>\n",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.getProcessedConfig",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise which resolves to the\ncapabilities object.",
      "startingLine": 305,
      "typeExpression": "webdriver.promise.Promise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.promise.Promise"
      },
      "typeList": [
        "webdriver.promise.Promise"
      ]
    },
    "returnString": "webdriver.promise.Promise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Fork another instance of browser for use in interactive tests.</p>\n",
    "example": "// Running with control flow enabled\nvar fork = browser.forkNewDriverInstance();\nfork.get('page1'); // 'page1' gotten by forked browser\n\n// Running with control flow disabled\nvar forked = await browser.forkNewDriverInstance().ready;\nawait forked.get('page1'); // 'page1' gotten by forked browser",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.forkNewDriverInstance",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Whether to navigate to current url on creation",
        "startingLine": 323,
        "typeExpression": "boolean=",
        "type": {
          "type": "NameExpression",
          "name": "boolean",
          "optional": true
        },
        "typeList": [
          "boolean"
        ],
        "optional": true,
        "name": "useSameUrl",
        "paramString": "boolean="
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Whether to apply same mock modules on creation",
        "startingLine": 324,
        "typeExpression": "boolean=",
        "type": {
          "type": "NameExpression",
          "name": "boolean",
          "optional": true
        },
        "typeList": [
          "boolean"
        ],
        "optional": true,
        "name": "copyMockModules",
        "paramString": "boolean="
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Whether to copy over changes to `baseUrl` and similar properties initialized to values in the the config.  Defaults to `true`",
        "startingLine": 325,
        "typeExpression": "boolean=",
        "type": {
          "type": "NameExpression",
          "name": "boolean",
          "optional": true
        },
        "typeList": [
          "boolean"
        ],
        "optional": true,
        "name": "copyConfigUpdates",
        "paramString": "boolean="
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A browser instance.",
      "startingLine": 328,
      "typeExpression": "ProtractorBrowser",
      "type": {
        "type": "NameExpression",
        "name": "ProtractorBrowser"
      },
      "typeList": [
        "ProtractorBrowser"
      ]
    },
    "returnString": "[ProtractorBrowser](ProtractorBrowser)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Restart the browser.  This is done by closing this browser instance and creating a new one.\nA promise resolving to the new instance is returned, and if this function was called on the\nglobal <code>browser</code> instance then Protractor will automatically overwrite the global <code>browser</code>\nvariable.</p>\n<p>When restarting a forked browser, it is the caller&#39;s job to overwrite references to the old\ninstance.</p>\n<p>This function behaves slightly differently depending on if the webdriver control flow is\nenabled.  If the control flow is enabled, the global <code>browser</code> object is synchronously\nreplaced. If the control flow is disabled, the global <code>browser</code> is replaced asynchronously\nafter the old driver quits.</p>\n<p>Set by the runner.</p>\n",
    "example": "// Running against global browser, with control flow enabled\nbrowser.get('page1');\nbrowser.restart();\nbrowser.get('page2'); // 'page2' gotten by restarted browser\n\n// Running against global browser, with control flow disabled\nawait browser.get('page1');\nawait browser.restart();\nawait browser.get('page2'); // 'page2' gotten by restarted browser\n\n// Running against forked browsers, with the control flow enabled\n// In this case, you may prefer `restartSync` (documented below)\nvar forked = browser.forkNewDriverInstance();\nfork.get('page1');\nfork.restart().then(function(fork) {\n  fork.get('page2'); // 'page2' gotten by restarted fork\n});\n\n// Running against forked browsers, with the control flow disabled\nvar forked = await browser.forkNewDriverInstance().ready;\nawait fork.get('page1');\nfork = await fork.restart();\nawait fork.get('page2'); // 'page2' gotten by restarted fork\n\n// Unexpected behavior can occur if you save references to the global `browser`\nvar savedBrowser = browser;\nbrowser.get('foo').then(function() {\n  console.log(browser === savedBrowser); // false\n});\nbrowser.restart();",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.restart",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise resolving to the restarted browser",
      "startingLine": 382,
      "typeExpression": "webdriver.promise.Promise<ProtractorBrowser>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "ProtractorBrowser"
          }
        ]
      },
      "typeList": [
        "webdriver.promise.Promise<ProtractorBrowser>"
      ]
    },
    "returnString": "webdriver.promise.Promise&lt;ProtractorBrowser&gt;",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Like <code>restart</code>, but instead of returning a promise resolving to the new browser instance,\nreturns the new browser instance directly.  Can only be used when the control flow is enabled.</p>\n",
    "example": "// Running against global browser\nbrowser.get('page1');\nbrowser.restartSync();\nbrowser.get('page2'); // 'page2' gotten by restarted browser\n\n// Running against forked browsers\nvar forked = browser.forkNewDriverInstance();\nfork.get('page1');\nfork = fork.restartSync();\nfork.get('page2'); // 'page2' gotten by restarted fork",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.restartSync",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The restarted browser",
      "startingLine": 405,
      "typeExpression": "ProtractorBrowser",
      "type": {
        "type": "NameExpression",
        "name": "ProtractorBrowser"
      },
      "typeList": [
        "ProtractorBrowser"
      ]
    },
    "returnString": "[ProtractorBrowser](ProtractorBrowser)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Instead of using a single root element, search through all angular apps\navailable on the page when finding elements or waiting for stability.\nOnly compatible with Angular2.</p>\n",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.useAllAngular2AppRoots",
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Instruct webdriver to wait until Angular has finished rendering and has\nno outstanding $http or $timeout calls before continuing.\nNote that Protractor automatically applies this command before every\nWebDriver action.</p>\n",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.waitForAngular",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "An optional description to be added to webdriver logs.",
        "startingLine": 475,
        "typeExpression": "string=",
        "type": {
          "type": "NameExpression",
          "name": "string",
          "optional": true
        },
        "typeList": [
          "string"
        ],
        "optional": true,
        "name": "opt_description",
        "paramString": "string="
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will resolve to the scripts return value.",
      "startingLine": 477,
      "typeExpression": "!webdriver.promise.Promise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.promise.Promise",
        "nullable": false
      },
      "typeList": [
        "webdriver.promise.Promise"
      ]
    },
    "returnString": "!webdriver.promise.Promise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Waits for Angular to finish rendering before searching for elements.</p>\n<br />See <code ng-non-bindable>webdriver.WebDriver.findElement</code>",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.findElement",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved to the located [<code ng-non-bindable>webdriver.WebElement</code>](webdriver.WebElement).",
      "startingLine": 582,
      "typeExpression": "!webdriver.WebElementPromise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.WebElementPromise",
        "nullable": false
      },
      "typeList": [
        "webdriver.WebElementPromise"
      ]
    },
    "returnString": "!webdriver.WebElementPromise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Waits for Angular to finish rendering before searching for elements.</p>\n<br />See <code ng-non-bindable>webdriver.WebDriver.findElements</code>",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.findElements",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved to an array of the located [<code ng-non-bindable>webdriver.WebElement</code>](webdriver.WebElement)s.",
      "startingLine": 591,
      "typeExpression": "!webdriver.promise.Promise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.promise.Promise",
        "nullable": false
      },
      "typeList": [
        "webdriver.promise.Promise"
      ]
    },
    "returnString": "!webdriver.promise.Promise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Tests if an element is present on the page.</p>\n<br />See <code ng-non-bindable>webdriver.WebDriver.isElementPresent</code>",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.isElementPresent",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will resolve to whether the element is present on the page.",
      "startingLine": 600,
      "typeExpression": "!webdriver.promise.Promise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.promise.Promise",
        "nullable": false
      },
      "typeList": [
        "webdriver.promise.Promise"
      ]
    },
    "returnString": "!webdriver.promise.Promise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Add a module to load before Angular whenever Protractor.get is called.\nModules will be registered after existing modules already on the page,\nso any module registered here will override preexisting modules with the\nsame name.</p>\n",
    "example": "browser.addMockModule('modName', function() {\n  angular.module('modName', []).value('foo', 'bar');\n});",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.addMockModule",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The name of the module to load or override.",
        "startingLine": 627,
        "typeExpression": "!string",
        "type": {
          "type": "NameExpression",
          "name": "string",
          "nullable": false
        },
        "typeList": [
          "string"
        ],
        "name": "name",
        "paramString": "!string"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The JavaScript to load the module. Note that this will be executed in the browser context, so it cannot access variables from outside its scope.",
        "startingLine": 628,
        "typeExpression": "!string|Function",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string",
              "nullable": false
            },
            {
              "type": "FunctionType",
              "params": []
            }
          ]
        },
        "typeList": [
          "string",
          "function()"
        ],
        "name": "script",
        "paramString": "!string&#124;Function"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Any additional arguments will be provided to the script and may be referenced using the `arguments` object.",
        "startingLine": 631,
        "typeExpression": "...*",
        "type": {
          "type": "AllLiteral",
          "repeatable": true
        },
        "typeList": [
          "*"
        ],
        "name": "varArgs",
        "paramString": "...*"
      }
    ],
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Clear the list of registered mock modules.</p>\n",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.clearMockModules",
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Remove a registered mock module.</p>\n",
    "example": "browser.removeMockModule('modName');",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.removeMockModule",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The name of the module to remove.",
        "startingLine": 654,
        "typeExpression": "!string",
        "type": {
          "type": "NameExpression",
          "name": "string",
          "nullable": false
        },
        "typeList": [
          "string"
        ],
        "name": "name",
        "paramString": "!string"
      }
    ],
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Get a list of the current mock modules.</p>\n",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.getRegisteredMockModules",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The list of mock modules.",
      "startingLine": 666,
      "typeExpression": "Array.<!string|Function>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "Array"
        },
        "applications": [
          {
            "type": "TypeUnion",
            "elements": [
              {
                "type": "NameExpression",
                "name": "string",
                "nullable": false
              },
              {
                "type": "FunctionType",
                "params": []
              }
            ]
          }
        ]
      },
      "typeList": [
        "Array.<!string|Function>"
      ]
    },
    "returnString": "Array.&lt;!string&#124;Function&gt;",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "See <code ng-non-bindable>webdriver.WebDriver.get</code><br />Navigate to the given destination and loads mock modules before Angular. Assumes that the page being loaded uses Angular. If you need to access a page which does not have Angular on load, use the wrapped webdriver directly.",
    "example": "browser.get('https://angularjs.org/');\nexpect(browser.getCurrentUrl()).toBe('https://angularjs.org/');",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.get",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Destination URL.",
        "startingLine": 692,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "destination",
        "paramString": "string"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Number of milliseconds to wait for Angular to start.",
        "startingLine": 693,
        "typeExpression": "number=",
        "type": {
          "type": "NameExpression",
          "name": "number",
          "optional": true
        },
        "typeList": [
          "number"
        ],
        "optional": true,
        "name": "opt_timeout",
        "paramString": "number="
      }
    ],
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "See <code ng-non-bindable>webdriver.WebDriver.refresh</code><br />Makes a full reload of the current page and loads mock modules before Angular. Assumes that the page being loaded uses Angular. If you need to access a page which does not have Angular on load, use the wrapped webdriver directly.",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.refresh",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Number of milliseconds to wait for Angular to start.",
        "startingLine": 828,
        "typeExpression": "number=",
        "type": {
          "type": "NameExpression",
          "name": "number",
          "optional": true
        },
        "typeList": [
          "number"
        ],
        "optional": true,
        "name": "opt_timeout",
        "paramString": "number="
      }
    ],
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Mixin navigation methods back into the navigation object so that\nthey are invoked as before, i.e. driver.navigate().refresh()</p>\n",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.navigate",
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Browse to another page using in-page navigation.</p>\n",
    "example": "browser.get('http://angular.github.io/protractor/#/tutorial');\nbrowser.setLocation('api');\nexpect(browser.getCurrentUrl())\n    .toBe('http://angular.github.io/protractor/#/api');",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.setLocation",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "In page URL using the same syntax as $location.url()",
        "startingLine": 859,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "url",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will resolve once page has been changed.",
      "startingLine": 860,
      "typeExpression": "!webdriver.promise.Promise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.promise.Promise",
        "nullable": false
      },
      "typeList": [
        "webdriver.promise.Promise"
      ]
    },
    "returnString": "!webdriver.promise.Promise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Deprecated, use <code>browser.getCurrentUrl()</code> instead.</p>\n<p>Despite its name, this function will generally return <code>$location.url()</code>, though in some\ncases it will return <code>$location.absUrl()</code> instead.  This function is only here for legacy\nusers, and will probably be removed in Protractor 6.0.</p>\n",
    "example": "browser.get('http://angular.github.io/protractor/#/api');\nexpect(browser.getLocationAbsUrl())\n    .toBe('http://angular.github.io/protractor/#/api');",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.getLocationAbsUrl",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The current absolute url from\nAngularJS.",
      "startingLine": 889,
      "typeExpression": "webdriver.promise.Promise<string>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "string"
          }
        ]
      },
      "typeList": [
        "webdriver.promise.Promise<string>"
      ]
    },
    "returnString": "webdriver.promise.Promise&lt;string&gt;",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Adds a task to the control flow to pause the test and inject helper\nfunctions\ninto the browser, so that debugging may be done in the browser console.</p>\n<p>This should be used under node in debug mode, i.e. with\nprotractor debug <configuration.js></p>\n",
    "example": "While in the debugger, commands can be scheduled through webdriver by\nentering the repl:\n  debug> repl\n  > element(by.input('user')).sendKeys('Laura');\n  > browser.debugger();\n  Press Ctrl + c to leave debug repl\n  debug> c\n\nThis will run the sendKeys command as the next task, then re-enter the\ndebugger.",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.debugger",
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>See browser.explore().</p>\n",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.enterRepl",
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Beta (unstable) explore function for entering the repl loop from\nany point in the control flow. Use browser.explore() in your test.\nDoes not require changes to the command line (no need to add &#39;debug&#39;).\nNote, if you are wrapping your own instance of Protractor, you must\nexpose globals &#39;browser&#39; and &#39;protractor&#39; for pause to work.</p>\n",
    "example": "element(by.id('foo')).click();\nbrowser.explore();\n// Execution will stop before the next click action.\nelement(by.id('bar')).click();",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.explore",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Optional port to use for the debugging\nprocess",
        "startingLine": 945,
        "typeExpression": "number=",
        "type": {
          "type": "NameExpression",
          "name": "number",
          "optional": true
        },
        "typeList": [
          "number"
        ],
        "optional": true,
        "name": "opt_debugPort",
        "paramString": "number="
      }
    ],
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Beta (unstable) pause function for debugging webdriver tests. Use\nbrowser.pause() in your test to enter the protractor debugger from that\npoint in the control flow.\nDoes not require changes to the command line (no need to add &#39;debug&#39;).\nNote, if you are wrapping your own instance of Protractor, you must\nexpose globals &#39;browser&#39; and &#39;protractor&#39; for pause to work.</p>\n",
    "example": "element(by.id('foo')).click();\nbrowser.pause();\n// Execution will stop before the next click action.\nelement(by.id('bar')).click();",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.pause",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Optional port to use for the debugging\nprocess",
        "startingLine": 980,
        "typeExpression": "number=",
        "type": {
          "type": "NameExpression",
          "name": "number",
          "optional": true
        },
        "typeList": [
          "number"
        ],
        "optional": true,
        "name": "opt_debugPort",
        "paramString": "number="
      }
    ],
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "description": "<p>Determine if the control flow is enabled.</p>\n",
    "fileName": "browser",
    "name": "ProtractorBrowser.prototype.controlFlowIsEnabled",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "true if the control flow is enabled, false otherwise.",
      "startingLine": 1008
    },
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/browser.ts"
  },
  {
    "alias": "element.all(locator)",
    "description": "<p>ElementArrayFinder is used for operations on an array of elements (as opposed\nto a single element).</p>\n<p>The ElementArrayFinder is used to set up a chain of conditions that identify\nan array of elements. In particular, you can call all(locator) and\nfilter(filterFn) to return a new ElementArrayFinder modified by the\nconditions, and you can call get(index) to return a single ElementFinder at\nposition &#39;index&#39;.</p>\n<p>Similar to jquery, ElementArrayFinder will search all branches of the DOM\nto find the elements that satisfy the conditions (i.e. all, filter, get).\nHowever, an ElementArrayFinder will not actually retrieve the elements until\nan action is called, which means it can be set up in helper files (i.e.\npage objects) before the page is available, and reused as the page changes.</p>\n<p>You can treat an ElementArrayFinder as an array of WebElements for most\npurposes, in particular, you may perform actions (i.e. click, getText) on\nthem as you would an array of WebElements. The action will apply to\nevery element identified by the ElementArrayFinder. ElementArrayFinder\nextends Promise, and once an action is performed on an ElementArrayFinder,\nthe latest result can be accessed using then, and will be returned as an\narray of the results; the array has length equal to the length of the\nelements found by the ElementArrayFinder and each result represents the\nresult of performing the action on the element. Unlike a WebElement, an\nElementArrayFinder will wait for the angular app to settle before\nperforming finds or actions.</p>\n",
    "example": "element.all(by.css('.items li')).then(function(items) {\n  expect(items.length).toBe(3);\n  expect(items[0].getText()).toBe('First');\n});\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\n$$('.items li').then(function(items) {\n  expect(items.length).toBe(3);\n  expect(items[0].getText()).toBe('First');\n});",
    "fileName": "element",
    "htmlView": "&lt;ul class=&quot;items&quot;&gt;\n  &lt;li&gt;First&lt;/li&gt;\n  &lt;li&gt;Second&lt;/li&gt;\n  &lt;li&gt;Third&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "ElementArrayFinder",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "A browser instance.",
        "startingLine": 79,
        "typeExpression": "ProtractorBrowser",
        "type": {
          "type": "NameExpression",
          "name": "ProtractorBrowser"
        },
        "typeList": [
          "ProtractorBrowser"
        ],
        "name": "browser",
        "paramString": "[ProtractorBrowser](ProtractorBrowser)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "A function that returns a list of the underlying Web Elements.",
        "startingLine": 80,
        "typeExpression": "function(): Array.<webdriver.WebElement>",
        "type": {
          "type": "FunctionType",
          "params": [],
          "result": {
            "type": "TypeApplication",
            "expression": {
              "type": "NameExpression",
              "name": "Array"
            },
            "applications": [
              {
                "type": "NameExpression",
                "name": "webdriver.WebElement"
              }
            ]
          }
        },
        "typeList": [
          "function(): Array.<webdriver.WebElement>"
        ],
        "name": "getWebElements",
        "paramString": "function(): Array.&lt;webdriver.WebElement&gt;"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The most relevant locator. It is only used for error reporting and ElementArrayFinder.locator.",
        "startingLine": 82,
        "typeExpression": "webdriver.Locator",
        "type": {
          "type": "NameExpression",
          "name": "webdriver.Locator"
        },
        "typeList": [
          "webdriver.Locator"
        ],
        "name": "locator",
        "paramString": "webdriver.Locator"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "An array of promises which will be retrieved with then. Resolves to the latest action result, or null if no action has been called.",
        "startingLine": 84,
        "typeExpression": "Array.<webdriver.promise.Promise>",
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "webdriver.promise.Promise"
            }
          ]
        },
        "typeList": [
          "Array.<webdriver.promise.Promise>"
        ],
        "name": "opt_actionResults",
        "paramString": "Array.&lt;webdriver.promise.Promise&gt;"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 87,
      "typeExpression": "ElementArrayFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementArrayFinder"
      },
      "typeList": [
        "ElementArrayFinder"
      ]
    },
    "returnString": "[ElementArrayFinder](ElementArrayFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<ul class=\"items\">\n  <li>First</li>\n  <li>Second</li>\n  <li>Third</li>\n</ul>"
  },
  {
    "description": "<p>Create a shallow copy of ElementArrayFinder.</p>\n",
    "fileName": "element",
    "name": "ElementArrayFinder.prototype.clone",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A shallow copy of this.",
      "startingLine": 118,
      "typeExpression": "!ElementArrayFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementArrayFinder",
        "nullable": false
      },
      "typeList": [
        "ElementArrayFinder"
      ]
    },
    "returnString": "&#33;[ElementArrayFinder](ElementArrayFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts"
  },
  {
    "alias": "element.all(locator).all(locator)",
    "description": "<p>Calls to ElementArrayFinder may be chained to find an array of elements\nusing the current elements in this ElementArrayFinder as the starting\npoint. This function returns a new ElementArrayFinder which would contain\nthe children elements found (and could also be empty).</p>\n",
    "example": "let foo = element.all(by.css('.parent')).all(by.css('.foo'));\nexpect(foo.getText()).toEqual(['1a', '2a']);\nlet baz = element.all(by.css('.parent')).all(by.css('.baz'));\nexpect(baz.getText()).toEqual(['1b']);\nlet nonexistent = element.all(by.css('.parent'))\n  .all(by.css('.NONEXISTENT'));\nexpect(nonexistent.getText()).toEqual(['']);\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\nlet foo = $$('.parent').$$('.foo');\nexpect(foo.getText()).toEqual(['1a', '2a']);\nlet baz = $$('.parent').$$('.baz');\nexpect(baz.getText()).toEqual(['1b']);\nlet nonexistent = $$('.parent').$$('.NONEXISTENT');\nexpect(nonexistent.getText()).toEqual(['']);",
    "fileName": "element",
    "htmlView": "&lt;div id='id1' class=&quot;parent&quot;&gt;\n  &lt;ul&gt;\n    &lt;li class=&quot;foo&quot;&gt;1a&lt;/li&gt;\n    &lt;li class=&quot;baz&quot;&gt;1b&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n&lt;div id='id2' class=&quot;parent&quot;&gt;\n  &lt;ul&gt;\n    &lt;li class=&quot;foo&quot;&gt;2a&lt;/li&gt;\n    &lt;li class=&quot;bar&quot;&gt;2b&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;",
    "name": "ElementArrayFinder.prototype.all",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 165,
        "typeExpression": "webdriver.Locator",
        "type": {
          "type": "NameExpression",
          "name": "webdriver.Locator"
        },
        "typeList": [
          "webdriver.Locator"
        ],
        "name": "subLocator",
        "paramString": "webdriver.Locator"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 166,
      "typeExpression": "ElementArrayFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementArrayFinder"
      },
      "typeList": [
        "ElementArrayFinder"
      ]
    },
    "returnString": "[ElementArrayFinder](ElementArrayFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<div id='id1' class=\"parent\">\n  <ul>\n    <li class=\"foo\">1a</li>\n    <li class=\"baz\">1b</li>\n  </ul>\n</div>\n<div id='id2' class=\"parent\">\n  <ul>\n    <li class=\"foo\">2a</li>\n    <li class=\"bar\">2b</li>\n  </ul>\n</div>"
  },
  {
    "alias": "element.all(locator).filter(filterFn)",
    "description": "<p>Apply a filter function to each element within the ElementArrayFinder.\nReturns a new ElementArrayFinder with all elements that pass the filter\nfunction. The filter function receives the ElementFinder as the first\nargument and the index as a second arg. This does not actually retrieve\nthe underlying list of elements, so it can be used in page objects.</p>\n",
    "example": "element.all(by.css('.items li')).filter(function(elem, index) {\n  return elem.getText().then(function(text) {\n    return text === 'Third';\n  });\n}).first().click();\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\n$$('.items li').filter(function(elem, index) {\n  return elem.getText().then(function(text) {\n    return text === 'Third';\n  });\n}).first().click();",
    "fileName": "element",
    "htmlView": "&lt;ul class=&quot;items&quot;&gt;\n  &lt;li class=&quot;one&quot;&gt;First&lt;/li&gt;\n  &lt;li class=&quot;two&quot;&gt;Second&lt;/li&gt;\n  &lt;li class=&quot;three&quot;&gt;Third&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "ElementArrayFinder.prototype.filter",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Filter function that will test if an element should be returned. filterFn can either return a boolean or a promise that resolves to a\nboolean",
        "startingLine": 236,
        "typeExpression": "function(ElementFinder, number): webdriver.WebElement.Promise",
        "type": {
          "type": "FunctionType",
          "params": [
            {
              "type": "NameExpression",
              "name": "ElementFinder"
            },
            {
              "type": "NameExpression",
              "name": "number"
            }
          ],
          "result": {
            "type": "NameExpression",
            "name": "webdriver.WebElement.Promise"
          }
        },
        "typeList": [
          "function(ElementFinder, number): webdriver.WebElement.Promise"
        ],
        "name": "filterFn",
        "paramString": "function([ElementFinder](ElementFinder), number): webdriver.WebElement.Promise"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A ElementArrayFinder that represents an\narray of element that satisfy the filter function.",
      "startingLine": 241,
      "typeExpression": "!ElementArrayFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementArrayFinder",
        "nullable": false
      },
      "typeList": [
        "ElementArrayFinder"
      ]
    },
    "returnString": "&#33;[ElementArrayFinder](ElementArrayFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<ul class=\"items\">\n  <li class=\"one\">First</li>\n  <li class=\"two\">Second</li>\n  <li class=\"three\">Third</li>\n</ul>"
  },
  {
    "alias": "element.all(locator).get(index)",
    "description": "<p>Get an element within the ElementArrayFinder by index. The index starts at 0.\nNegative indices are wrapped (i.e. -i means ith element from last)\nThis does not actually retrieve the underlying element.</p>\n",
    "example": "let list = element.all(by.css('.items li'));\nexpect(list.get(0).getText()).toBe('First');\nexpect(list.get(1).getText()).toBe('Second');\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\nlet list = $$('.items li');\nexpect(list.get(0).getText()).toBe('First');\nexpect(list.get(1).getText()).toBe('Second');",
    "fileName": "element",
    "htmlView": "&lt;ul class=&quot;items&quot;&gt;\n  &lt;li&gt;First&lt;/li&gt;\n  &lt;li&gt;Second&lt;/li&gt;\n  &lt;li&gt;Third&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "ElementArrayFinder.prototype.get",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Element index.",
        "startingLine": 286,
        "typeExpression": "number|webdriver.promise.Promise",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "NameExpression",
              "name": "number"
            },
            {
              "type": "NameExpression",
              "name": "webdriver.promise.Promise"
            }
          ]
        },
        "typeList": [
          "number",
          "webdriver.promise.Promise"
        ],
        "name": "index",
        "paramString": "number&#124;webdriver.promise.Promise"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "finder representing element at the given index.",
      "startingLine": 287,
      "typeExpression": "ElementFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementFinder"
      },
      "typeList": [
        "ElementFinder"
      ]
    },
    "returnString": "[ElementFinder](ElementFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<ul class=\"items\">\n  <li>First</li>\n  <li>Second</li>\n  <li>Third</li>\n</ul>"
  },
  {
    "alias": "element.all(locator).first()",
    "description": "<p>Get the first matching element for the ElementArrayFinder. This does not\nactually retrieve the underlying element.</p>\n",
    "example": "let first = element.all(by.css('.items li')).first();\nexpect(first.getText()).toBe('First');\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\nlet first = $$('.items li').first();\nexpect(first.getText()).toBe('First');",
    "fileName": "element",
    "htmlView": "&lt;ul class=&quot;items&quot;&gt;\n  &lt;li&gt;First&lt;/li&gt;\n  &lt;li&gt;Second&lt;/li&gt;\n  &lt;li&gt;Third&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "ElementArrayFinder.prototype.first",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "finder representing the first matching element",
      "startingLine": 328,
      "typeExpression": "ElementFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementFinder"
      },
      "typeList": [
        "ElementFinder"
      ]
    },
    "returnString": "[ElementFinder](ElementFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<ul class=\"items\">\n  <li>First</li>\n  <li>Second</li>\n  <li>Third</li>\n</ul>"
  },
  {
    "alias": "element.all(locator).last()",
    "description": "<p>Get the last matching element for the ElementArrayFinder. This does not\nactually retrieve the underlying element.</p>\n",
    "example": "let last = element.all(by.css('.items li')).last();\nexpect(last.getText()).toBe('Third');\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\nlet last = $$('.items li').last();\nexpect(last.getText()).toBe('Third');",
    "fileName": "element",
    "htmlView": "&lt;ul class=&quot;items&quot;&gt;\n  &lt;li&gt;First&lt;/li&gt;\n  &lt;li&gt;Second&lt;/li&gt;\n  &lt;li&gt;Third&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "ElementArrayFinder.prototype.last",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "finder representing the last matching element",
      "startingLine": 355,
      "typeExpression": "ElementFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementFinder"
      },
      "typeList": [
        "ElementFinder"
      ]
    },
    "returnString": "[ElementFinder](ElementFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<ul class=\"items\">\n  <li>First</li>\n  <li>Second</li>\n  <li>Third</li>\n</ul>"
  },
  {
    "alias": "$$(cssSelector)",
    "description": "<p>Shorthand function for finding arrays of elements by css.\n<code>element.all(by.css(&#39;.abc&#39;))</code> is equivalent to <code>$$(&#39;.abc&#39;)</code></p>\n",
    "example": "// The following two blocks of code are equivalent.\nlet list = element.all(by.css('.count span'));\nexpect(list.count()).toBe(2);\nexpect(list.get(0).getText()).toBe('First');\nexpect(list.get(1).getText()).toBe('Second');\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\nlet list = $$('.count span');\nexpect(list.count()).toBe(2);\nexpect(list.get(0).getText()).toBe('First');\nexpect(list.get(1).getText()).toBe('Second');",
    "fileName": "element",
    "htmlView": "&lt;div class=&quot;count&quot;&gt;\n  &lt;span class=&quot;one&quot;&gt;First&lt;/span&gt;\n  &lt;span class=&quot;two&quot;&gt;Second&lt;/span&gt;\n&lt;/div&gt;",
    "name": "ElementArrayFinder.prototype.$$",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "a css selector",
        "startingLine": 385,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "selector",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "which identifies the array of the located [<code ng-non-bindable>webdriver.WebElement</code>](webdriver.WebElement)s.",
      "startingLine": 386,
      "typeExpression": "ElementArrayFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementArrayFinder"
      },
      "typeList": [
        "ElementArrayFinder"
      ]
    },
    "returnString": "[ElementArrayFinder](ElementArrayFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<div class=\"count\">\n  <span class=\"one\">First</span>\n  <span class=\"two\">Second</span>\n</div>"
  },
  {
    "alias": "element.all(locator).count()",
    "description": "<p>Count the number of elements represented by the ElementArrayFinder.</p>\n",
    "example": "let list = element.all(by.css('.items li'));\nexpect(list.count()).toBe(3);\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\nlet list = $$('.items li');\nexpect(list.count()).toBe(3);",
    "fileName": "element",
    "htmlView": "&lt;ul class=&quot;items&quot;&gt;\n  &lt;li&gt;First&lt;/li&gt;\n  &lt;li&gt;Second&lt;/li&gt;\n  &lt;li&gt;Third&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "ElementArrayFinder.prototype.count",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise which resolves to the number of elements matching the locator.",
      "startingLine": 423,
      "typeExpression": "!webdriver.promise.Promise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.promise.Promise",
        "nullable": false
      },
      "typeList": [
        "webdriver.promise.Promise"
      ]
    },
    "returnString": "!webdriver.promise.Promise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<ul class=\"items\">\n  <li>First</li>\n  <li>Second</li>\n  <li>Third</li>\n</ul>"
  },
  {
    "alias": "element.all(locator).isPresent()",
    "description": "<p>Returns true if there are any elements present that match the finder.</p>\n",
    "example": "expect($('.item').isPresent()).toBeTruthy();",
    "fileName": "element",
    "name": "ElementArrayFinder.prototype.isPresent",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 446,
      "typeExpression": "Promise<boolean>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "boolean"
          }
        ]
      },
      "typeList": [
        "Promise<boolean>"
      ]
    },
    "returnString": "Promise&lt;boolean&gt;",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts"
  },
  {
    "description": "<p>Returns the most relevant locator.</p>\n",
    "example": "// returns by.css('#ID1')\n$('#ID1').locator();\n\n// returns by.css('#ID2')\n$('#ID1').$('#ID2').locator();\n\n// returns by.css('#ID1')\n$$('#ID1').filter(filterFn).get(0).click().locator();",
    "fileName": "element",
    "name": "ElementArrayFinder.prototype.locator",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 466,
      "typeExpression": "webdriver.Locator",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.Locator"
      },
      "typeList": [
        "webdriver.Locator"
      ]
    },
    "returnString": "webdriver.Locator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts"
  },
  {
    "alias": "element.all(locator).then(thenFunction)",
    "description": "<p>Retrieve the elements represented by the ElementArrayFinder. The input\nfunction is passed to the resulting promise, which resolves to an\narray of ElementFinders.</p>\n",
    "example": "element.all(by.css('.items li')).then(function(arr) {\n  expect(arr.length).toEqual(3);\n});\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\n$$('.items li').then(function(arr) {\n  expect(arr.length).toEqual(3);\n});",
    "fileName": "element",
    "htmlView": "&lt;ul class=&quot;items&quot;&gt;\n  &lt;li&gt;First&lt;/li&gt;\n  &lt;li&gt;Second&lt;/li&gt;\n  &lt;li&gt;Third&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "ElementArrayFinder.prototype.then",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 550,
        "typeExpression": "function(Array.<ElementFinder>)",
        "type": {
          "type": "FunctionType",
          "params": [
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "ElementFinder"
                }
              ]
            }
          ]
        },
        "typeList": [
          "function(Array.<ElementFinder>)"
        ],
        "name": "fn",
        "paramString": "function(Array.&lt;ElementFinder&gt;)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 551,
        "typeExpression": "function(Error)",
        "type": {
          "type": "FunctionType",
          "params": [
            {
              "type": "NameExpression",
              "name": "Error"
            }
          ]
        },
        "typeList": [
          "function(Error)"
        ],
        "name": "errorFn",
        "paramString": "function(Error)"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise which will resolve to an array of ElementFinders represented by the ElementArrayFinder.",
      "startingLine": 553,
      "typeExpression": "!webdriver.promise.Promise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.promise.Promise",
        "nullable": false
      },
      "typeList": [
        "webdriver.promise.Promise"
      ]
    },
    "returnString": "!webdriver.promise.Promise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<ul class=\"items\">\n  <li>First</li>\n  <li>Second</li>\n  <li>Third</li>\n</ul>"
  },
  {
    "alias": "element.all(locator).each(eachFunction)",
    "description": "<p>Calls the input function on each ElementFinder represented by the\nElementArrayFinder.</p>\n",
    "example": "element.all(by.css('.items li')).each(function(element, index) {\n  // Will print 0 First, 1 Second, 2 Third.\n  element.getText().then(function (text) {\n    console.log(index, text);\n  });\n});\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\n$$('.items li').each(function(element, index) {\n  // Will print 0 First, 1 Second, 2 Third.\n  element.getText().then(function (text) {\n    console.log(index, text);\n  });\n});",
    "fileName": "element",
    "htmlView": "&lt;ul class=&quot;items&quot;&gt;\n  &lt;li&gt;First&lt;/li&gt;\n  &lt;li&gt;Second&lt;/li&gt;\n  &lt;li&gt;Third&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "ElementArrayFinder.prototype.each",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Input function",
        "startingLine": 593,
        "typeExpression": "function(ElementFinder)",
        "type": {
          "type": "FunctionType",
          "params": [
            {
              "type": "NameExpression",
              "name": "ElementFinder"
            }
          ]
        },
        "typeList": [
          "function(ElementFinder)"
        ],
        "name": "fn",
        "paramString": "function([ElementFinder](ElementFinder))"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will resolve when the function has been called on all the ElementFinders. The promise will resolve to null.",
      "startingLine": 595,
      "typeExpression": "!webdriver.promise.Promise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.promise.Promise",
        "nullable": false
      },
      "typeList": [
        "webdriver.promise.Promise"
      ]
    },
    "returnString": "!webdriver.promise.Promise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<ul class=\"items\">\n  <li>First</li>\n  <li>Second</li>\n  <li>Third</li>\n</ul>"
  },
  {
    "alias": "element.all(locator).map(mapFunction)",
    "description": "<p>Apply a map function to each element within the ElementArrayFinder. The\ncallback receives the ElementFinder as the first argument and the index as\na second arg.</p>\n",
    "example": "let items = element.all(by.css('.items li')).map(function(elm, index) {\n  return {\n    index: index,\n    text: elm.getText(),\n    class: elm.getAttribute('class')\n  };\n});\nexpect(items).toEqual([\n  {index: 0, text: 'First', class: 'one'},\n  {index: 1, text: 'Second', class: 'two'},\n  {index: 2, text: 'Third', class: 'three'}\n]);\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\nlet items = $$('.items li').map(function(elm, index) {\n  return {\n    index: index,\n    text: elm.getText(),\n    class: elm.getAttribute('class')\n  };\n});\nexpect(items).toEqual([\n  {index: 0, text: 'First', class: 'one'},\n  {index: 1, text: 'Second', class: 'two'},\n  {index: 2, text: 'Third', class: 'three'}\n]);",
    "fileName": "element",
    "htmlView": "&lt;ul class=&quot;items&quot;&gt;\n  &lt;li class=&quot;one&quot;&gt;First&lt;/li&gt;\n  &lt;li class=&quot;two&quot;&gt;Second&lt;/li&gt;\n  &lt;li class=&quot;three&quot;&gt;Third&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "ElementArrayFinder.prototype.map",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Map function that will be applied to each element.",
        "startingLine": 646,
        "typeExpression": "function(ElementFinder, number)",
        "type": {
          "type": "FunctionType",
          "params": [
            {
              "type": "NameExpression",
              "name": "ElementFinder"
            },
            {
              "type": "NameExpression",
              "name": "number"
            }
          ]
        },
        "typeList": [
          "function(ElementFinder, number)"
        ],
        "name": "mapFn",
        "paramString": "function([ElementFinder](ElementFinder), number)"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that resolves to an array of values returned by the map function.",
      "startingLine": 648,
      "typeExpression": "!webdriver.promise.Promise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.promise.Promise",
        "nullable": false
      },
      "typeList": [
        "webdriver.promise.Promise"
      ]
    },
    "returnString": "!webdriver.promise.Promise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<ul class=\"items\">\n  <li class=\"one\">First</li>\n  <li class=\"two\">Second</li>\n  <li class=\"three\">Third</li>\n</ul>"
  },
  {
    "alias": "element.all(locator).reduce(reduceFn)",
    "description": "<p>Apply a reduce function against an accumulator and every element found\nusing the locator (from left-to-right). The reduce function has to reduce\nevery element into a single value (the accumulator). Returns promise of\nthe accumulator. The reduce function receives the accumulator, current\nElementFinder, the index, and the entire array of ElementFinders,\nrespectively.</p>\n",
    "example": "let value = element.all(by.css('.items li')).reduce(function(acc, elem) {\n  return elem.getText().then(function(text) {\n    return acc + text + ' ';\n  });\n}, '');\n\nexpect(value).toEqual('First Second Third ');\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\nlet value = $$('.items li').reduce(function(acc, elem) {\n  return elem.getText().then(function(text) {\n    return acc + text + ' ';\n  });\n}, '');\n\nexpect(value).toEqual('First Second Third ');",
    "fileName": "element",
    "htmlView": "&lt;ul class=&quot;items&quot;&gt;\n  &lt;li class=&quot;one&quot;&gt;First&lt;/li&gt;\n  &lt;li class=&quot;two&quot;&gt;Second&lt;/li&gt;\n  &lt;li class=&quot;three&quot;&gt;Third&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "ElementArrayFinder.prototype.reduce",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Reduce function that reduces every element into a single\nvalue.",
        "startingLine": 697,
        "typeExpression": "function(number, ElementFinder, number, Array.<ElementFinder>)",
        "type": {
          "type": "FunctionType",
          "params": [
            {
              "type": "NameExpression",
              "name": "number"
            },
            {
              "type": "NameExpression",
              "name": "ElementFinder"
            },
            {
              "type": "NameExpression",
              "name": "number"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "ElementFinder"
                }
              ]
            }
          ]
        },
        "typeList": [
          "function(number, ElementFinder, number, Array.<ElementFinder>)"
        ],
        "name": "reduceFn",
        "paramString": "function(number, [ElementFinder](ElementFinder), number, Array.&lt;ElementFinder&gt;)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Initial value of the accumulator.",
        "startingLine": 700,
        "typeExpression": "*",
        "type": {
          "type": "AllLiteral"
        },
        "typeList": [
          "*"
        ],
        "name": "initialValue",
        "paramString": "*"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that resolves to the final value of the accumulator.",
      "startingLine": 701,
      "typeExpression": "!webdriver.promise.Promise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.promise.Promise",
        "nullable": false
      },
      "typeList": [
        "webdriver.promise.Promise"
      ]
    },
    "returnString": "!webdriver.promise.Promise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<ul class=\"items\">\n  <li class=\"one\">First</li>\n  <li class=\"two\">Second</li>\n  <li class=\"three\">Third</li>\n</ul>"
  },
  {
    "description": "<p>Evaluates the input as if it were on the scope of the current underlying\nelements.</p>\n",
    "example": "let value = element.all(by.css('.foo')).evaluate('letiableInScope');\n\n// Or using the shortcut $$() notation instead of element.all(by.css()):\n\nlet value = $$('.foo').evaluate('letiableInScope');",
    "fileName": "element",
    "htmlView": "&lt;span class=&quot;foo&quot;&gt;{{letiableInScope}}&lt;/span&gt;",
    "name": "ElementArrayFinder.prototype.evaluate",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 728,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "expression",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "which resolves to the evaluated expression for each underlying element. The result will be resolved as in <code ng-non-bindable>webdriver.WebDriver.executeScript</code>. In summary - primitives will be resolved as is, functions will be converted to string, and elements will be returned as a WebElement.",
      "startingLine": 730,
      "typeExpression": "ElementArrayFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementArrayFinder"
      },
      "typeList": [
        "ElementArrayFinder"
      ]
    },
    "returnString": "[ElementArrayFinder](ElementArrayFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<span class=\"foo\">{{letiableInScope}}</span>"
  },
  {
    "description": "<p>Determine if animation is allowed on the current underlying elements.</p>\n",
    "example": "// Turns off ng-animate animations for all elements in the <body>\nelement(by.css('body')).allowAnimations(false);\n\n// Or using the shortcut $() notation instead of element(by.css()):\n\n$('body').allowAnimations(false);",
    "fileName": "element",
    "name": "ElementArrayFinder.prototype.allowAnimations",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 745,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "value",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "which resolves to whether animation is\nallowed.",
      "startingLine": 755,
      "typeExpression": "ElementArrayFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementArrayFinder"
      },
      "typeList": [
        "ElementArrayFinder"
      ]
    },
    "returnString": "[ElementArrayFinder](ElementArrayFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts"
  },
  {
    "alias": "element(locator)",
    "description": "<p>The ElementFinder simply represents a single element of an\nElementArrayFinder (and is more like a convenience object). As a result,\nanything that can be done with an ElementFinder, can also be done using\nan ElementArrayFinder.</p>\n<p>The ElementFinder can be treated as a WebElement for most purposes, in\nparticular, you may perform actions (i.e. click, getText) on them as you\nwould a WebElement. Once an action is performed on an ElementFinder, the\nlatest result from the chain can be accessed using the then method.\nUnlike a WebElement, an ElementFinder will wait for angular to settle before\nperforming finds or actions.</p>\n<p>ElementFinder can be used to build a chain of locators that is used to find\nan element. An ElementFinder does not actually attempt to find the element\nuntil an action is called, which means they can be set up in helper files\nbefore the page is available.</p>\n",
    "example": "// Find element with {{scopelet}} syntax.\nelement(by.binding('person.name')).getText().then(function(name) {\n  expect(name).toBe('Foo');\n});\n\n// Find element with ng-bind=\"scopelet\" syntax.\nexpect(element(by.binding('person.email')).getText()).toBe('foo@bar.com');\n\n// Find by model.\nlet input = element(by.model('person.name'));\ninput.sendKeys('123');\nexpect(input.getAttribute('value')).toBe('Foo123');",
    "extends": "{webdriver.WebElement}",
    "fileName": "element",
    "htmlView": "&lt;span&gt;{{person.name}}&lt;/span&gt;\n&lt;span ng-bind=&quot;person.email&quot;&gt;&lt;/span&gt;\n&lt;input type=&quot;text&quot; ng-model=&quot;person.name&quot;/&gt;",
    "name": "ElementFinder",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "A browser instance.",
        "startingLine": 807,
        "typeExpression": "ProtractorBrowser",
        "type": {
          "type": "NameExpression",
          "name": "ProtractorBrowser"
        },
        "typeList": [
          "ProtractorBrowser"
        ],
        "name": "browser_",
        "paramString": "[ProtractorBrowser](ProtractorBrowser)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The ElementArrayFinder that this is branched from.",
        "startingLine": 808,
        "typeExpression": "ElementArrayFinder",
        "type": {
          "type": "NameExpression",
          "name": "ElementArrayFinder"
        },
        "typeList": [
          "ElementArrayFinder"
        ],
        "name": "elementArrayFinder",
        "paramString": "[ElementArrayFinder](ElementArrayFinder)"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 810,
      "typeExpression": "ElementFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementFinder"
      },
      "typeList": [
        "ElementFinder"
      ]
    },
    "returnString": "[ElementFinder](ElementFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<span>{{person.name}}</span>\n<span ng-bind=\"person.email\"></span>\n<input type=\"text\" ng-model=\"person.name\"/>"
  },
  {
    "description": "<p>Create a shallow copy of ElementFinder.</p>\n",
    "fileName": "element",
    "name": "ElementFinder.prototype.clone",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A shallow copy of this.",
      "startingLine": 878,
      "typeExpression": "!ElementFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementFinder",
        "nullable": false
      },
      "typeList": [
        "ElementFinder"
      ]
    },
    "returnString": "&#33;[ElementFinder](ElementFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts"
  },
  {
    "description": "See [<code ng-non-bindable>ElementArrayFinder.prototype.locator</code>](ElementArrayFinder.prototype.locator)",
    "fileName": "element",
    "name": "ElementFinder.prototype.locator",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 888,
      "typeExpression": "webdriver.Locator",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.Locator"
      },
      "typeList": [
        "webdriver.Locator"
      ]
    },
    "returnString": "webdriver.Locator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts"
  },
  {
    "alias": "element(locator).getWebElement()",
    "description": "<p>Returns the WebElement represented by this ElementFinder.\nThrows the WebDriver error if the element doesn&#39;t exist.</p>\n",
    "example": "// The following four expressions are equivalent.\n$('.parent').getWebElement();\nelement(by.css('.parent')).getWebElement();\nbrowser.driver.findElement(by.css('.parent'));\nbrowser.findElement(by.css('.parent'));",
    "fileName": "element",
    "htmlView": "&lt;div class=&quot;parent&quot;&gt;\n  some text\n&lt;/div&gt;",
    "name": "ElementFinder.prototype.getWebElement",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 910,
      "typeExpression": "webdriver.WebElementPromise",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.WebElementPromise"
      },
      "typeList": [
        "webdriver.WebElementPromise"
      ]
    },
    "returnString": "webdriver.WebElementPromise",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<div class=\"parent\">\n  some text\n</div>"
  },
  {
    "alias": "element(locator).all(locator)",
    "description": "<p>Calls to <code ng-non-bindable>all</code> may be chained to find an array of elements within a\nparent.</p>\n",
    "example": "let items = element(by.css('.parent')).all(by.tagName('li'));\n\n// Or using the shortcut $() notation instead of element(by.css()):\n\nlet items = $('.parent').all(by.tagName('li'));",
    "fileName": "element",
    "htmlView": "&lt;div class=&quot;parent&quot;&gt;\n  &lt;ul&gt;\n    &lt;li class=&quot;one&quot;&gt;First&lt;/li&gt;\n    &lt;li class=&quot;two&quot;&gt;Second&lt;/li&gt;\n    &lt;li class=&quot;three&quot;&gt;Third&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;",
    "name": "ElementFinder.prototype.all",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 939,
        "typeExpression": "webdriver.Locator",
        "type": {
          "type": "NameExpression",
          "name": "webdriver.Locator"
        },
        "typeList": [
          "webdriver.Locator"
        ],
        "name": "subLocator",
        "paramString": "webdriver.Locator"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 940,
      "typeExpression": "ElementArrayFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementArrayFinder"
      },
      "typeList": [
        "ElementArrayFinder"
      ]
    },
    "returnString": "[ElementArrayFinder](ElementArrayFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<div class=\"parent\">\n  <ul>\n    <li class=\"one\">First</li>\n    <li class=\"two\">Second</li>\n    <li class=\"three\">Third</li>\n  </ul>\n</div>"
  },
  {
    "alias": "element(locator).element(locator)",
    "description": "<p>Calls to <code ng-non-bindable>element</code> may be chained to find elements within a parent.</p>\n",
    "example": "// Chain 2 element calls.\nlet child = element(by.css('.parent')).\n    element(by.css('.child'));\nexpect(child.getText()).toBe('Child text\\n555-123-4567');\n\n// Chain 3 element calls.\nlet triple = element(by.css('.parent')).\n    element(by.css('.child')).\n    element(by.binding('person.phone'));\nexpect(triple.getText()).toBe('555-123-4567');\n\n// Or using the shortcut $() notation instead of element(by.css()):\n\n// Chain 2 element calls.\nlet child = $('.parent').$('.child');\nexpect(child.getText()).toBe('Child text\\n555-123-4567');\n\n// Chain 3 element calls.\nlet triple = $('.parent').$('.child').\n    element(by.binding('person.phone'));\nexpect(triple.getText()).toBe('555-123-4567');",
    "fileName": "element",
    "htmlView": "&lt;div class=&quot;parent&quot;&gt;\n  &lt;div class=&quot;child&quot;&gt;\n    Child text\n    &lt;div&gt;{{person.phone}}&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;",
    "name": "ElementFinder.prototype.element",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 980,
        "typeExpression": "webdriver.Locator",
        "type": {
          "type": "NameExpression",
          "name": "webdriver.Locator"
        },
        "typeList": [
          "webdriver.Locator"
        ],
        "name": "subLocator",
        "paramString": "webdriver.Locator"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 981,
      "typeExpression": "ElementFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementFinder"
      },
      "typeList": [
        "ElementFinder"
      ]
    },
    "returnString": "[ElementFinder](ElementFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<div class=\"parent\">\n  <div class=\"child\">\n    Child text\n    <div>{{person.phone}}</div>\n  </div>\n</div>"
  },
  {
    "alias": "element(locator).all(selector)",
    "description": "<p>Calls to <code ng-non-bindable>$$</code> may be chained to find an array of elements within a\nparent.</p>\n",
    "example": "let items = element(by.css('.parent')).$$('li');\n\n// Or using the shortcut $() notation instead of element(by.css()):\n\nlet items = $('.parent').$$('li');",
    "fileName": "element",
    "htmlView": "&lt;div class=&quot;parent&quot;&gt;\n  &lt;ul&gt;\n    &lt;li class=&quot;one&quot;&gt;First&lt;/li&gt;\n    &lt;li class=&quot;two&quot;&gt;Second&lt;/li&gt;\n    &lt;li class=&quot;three&quot;&gt;Third&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;",
    "name": "ElementFinder.prototype.$$",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "a css selector",
        "startingLine": 1007,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "selector",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 1008,
      "typeExpression": "ElementArrayFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementArrayFinder"
      },
      "typeList": [
        "ElementArrayFinder"
      ]
    },
    "returnString": "[ElementArrayFinder](ElementArrayFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<div class=\"parent\">\n  <ul>\n    <li class=\"one\">First</li>\n    <li class=\"two\">Second</li>\n    <li class=\"three\">Third</li>\n  </ul>\n</div>"
  },
  {
    "alias": "element(locator).$(selector)",
    "description": "<p>Calls to <code ng-non-bindable>$</code> may be chained to find elements within a parent.</p>\n",
    "example": "// Chain 2 element calls.\nlet child = element(by.css('.parent')).\n    $('.child');\nexpect(child.getText()).toBe('Child text\\n555-123-4567');\n\n// Chain 3 element calls.\nlet triple = element(by.css('.parent')).\n    $('.child').\n    element(by.binding('person.phone'));\nexpect(triple.getText()).toBe('555-123-4567');\n\n// Or using the shortcut $() notation instead of element(by.css()):\n\n// Chain 2 element calls.\nlet child = $('.parent').$('.child');\nexpect(child.getText()).toBe('Child text\\n555-123-4567');\n\n// Chain 3 element calls.\nlet triple = $('.parent').$('.child').\n    element(by.binding('person.phone'));\nexpect(triple.getText()).toBe('555-123-4567');",
    "fileName": "element",
    "htmlView": "&lt;div class=&quot;parent&quot;&gt;\n  &lt;div class=&quot;child&quot;&gt;\n    Child text\n    &lt;div&gt;{{person.phone}}&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;",
    "name": "ElementFinder.prototype.$",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "A css selector",
        "startingLine": 1048,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "selector",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 1049,
      "typeExpression": "ElementFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementFinder"
      },
      "typeList": [
        "ElementFinder"
      ]
    },
    "returnString": "[ElementFinder](ElementFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<div class=\"parent\">\n  <div class=\"child\">\n    Child text\n    <div>{{person.phone}}</div>\n  </div>\n</div>"
  },
  {
    "description": "<p>Determine whether the element is present on the page.</p>\n",
    "example": "// Element exists.\nexpect(element(by.binding('person.name')).isPresent()).toBe(true);\n\n// Element not present.\nexpect(element(by.binding('notPresent')).isPresent()).toBe(false);",
    "fileName": "element",
    "htmlView": "&lt;span&gt;{{person.name}}&lt;/span&gt;",
    "name": "ElementFinder.prototype.isPresent",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "which resolves to whether the element is present on the page.",
      "startingLine": 1067,
      "typeExpression": "webdriver.promise.Promise<boolean>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "boolean"
          }
        ]
      },
      "typeList": [
        "webdriver.promise.Promise<boolean>"
      ]
    },
    "returnString": "webdriver.promise.Promise&lt;boolean&gt;",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<span>{{person.name}}</span>"
  },
  {
    "description": "<p>Same as ElementFinder.isPresent(), except this checks whether the element\nidentified by the subLocator is present, rather than the current element\nfinder, i.e.: <code>element(by.css(&#39;#abc&#39;)).element(by.css(&#39;#def&#39;)).isPresent()</code>\nis identical to <code>element(by.css(&#39;#abc&#39;)).isElementPresent(by.css(&#39;#def&#39;))</code>.</p>\n<p>// Or using the shortcut $() notation instead of element(by.css()):</p>\n<p><code>$(&#39;#abc&#39;).$(&#39;#def&#39;).isPresent()</code> is identical to\n<code>$(&#39;#abc&#39;).isElementPresent($(&#39;#def&#39;))</code>.</p>\n<br />See <code ng-non-bindable>ElementFinder.isPresent</code>",
    "fileName": "element",
    "name": "ElementFinder.prototype.isElementPresent",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Locator for element to look for.",
        "startingLine": 1093,
        "typeExpression": "webdriver.Locator",
        "type": {
          "type": "NameExpression",
          "name": "webdriver.Locator"
        },
        "typeList": [
          "webdriver.Locator"
        ],
        "name": "subLocator",
        "paramString": "webdriver.Locator"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "which resolves to whether the subelement is present on the page.",
      "startingLine": 1094,
      "typeExpression": "webdriver.promise.Promise<boolean>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "boolean"
          }
        ]
      },
      "typeList": [
        "webdriver.promise.Promise<boolean>"
      ]
    },
    "returnString": "webdriver.promise.Promise&lt;boolean&gt;",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts"
  },
  {
    "description": "<p>Evaluates the input as if it were on the scope of the current element.</p>\n<br />See [<code ng-non-bindable>ElementArrayFinder.prototype.evaluate</code>](ElementArrayFinder.prototype.evaluate)",
    "example": "let value = element(by.id('foo')).evaluate('letiableInScope');",
    "fileName": "element",
    "htmlView": "&lt;span id=&quot;foo&quot;&gt;{{letiableInScope}}&lt;/span&gt;",
    "name": "ElementFinder.prototype.evaluate",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 1115,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "expression",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "which resolves to the evaluated expression.",
      "startingLine": 1117,
      "typeExpression": "ElementFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementFinder"
      },
      "typeList": [
        "ElementFinder"
      ]
    },
    "returnString": "[ElementFinder](ElementFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts",
    "view": "<span id=\"foo\">{{letiableInScope}}</span>"
  },
  {
    "description": "See <code ng-non-bindable>ElementArrayFinder.prototype.allowAnimations.</code>",
    "fileName": "element",
    "name": "ElementFinder.prototype.allowAnimations",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 1124,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "value",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "which resolves to whether animation is allowed.",
      "startingLine": 1126,
      "typeExpression": "ElementFinder",
      "type": {
        "type": "NameExpression",
        "name": "ElementFinder"
      },
      "typeList": [
        "ElementFinder"
      ]
    },
    "returnString": "[ElementFinder](ElementFinder)",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts"
  },
  {
    "description": "<p>Compares an element to this one for equality.</p>\n",
    "fileName": "element",
    "name": "ElementFinder.prototype.equals",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "element to compare to.",
        "startingLine": 1134,
        "typeExpression": "!ElementFinder|!webdriver.WebElement",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "NameExpression",
              "name": "ElementFinder",
              "nullable": false
            },
            {
              "type": "NameExpression",
              "name": "webdriver.WebElement",
              "nullable": false
            }
          ]
        },
        "typeList": [
          "ElementFinder",
          "webdriver.WebElement"
        ],
        "name": "The",
        "paramString": "!ElementFinder&#124;!webdriver.WebElement"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved to whether the two WebElements are equal.",
      "startingLine": 1136,
      "typeExpression": "!webdriver.promise.Promise.<boolean>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "boolean"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<boolean>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;boolean&gt;",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/element.ts"
  },
  {
    "alias": "by",
    "description": "<p>The Protractor Locators. These provide ways of finding elements in\nAngular applications by binding, model, etc.</p>\n",
    "extends": "{webdriver.By}",
    "fileName": "locators",
    "name": "ProtractorBy",
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts"
  },
  {
    "alias": "by.addLocator(locatorName, functionOrScript)",
    "description": "<p>Add a locator to this instance of ProtractorBy. This locator can then be\nused with element(by.locatorName(args)).</p>\n",
    "example": "// Add the custom locator.\nby.addLocator('buttonTextSimple',\n    function(buttonText, opt_parentElement, opt_rootSelector) {\n  // This function will be serialized as a string and will execute in the\n  // browser. The first argument is the text for the button. The second\n  // argument is the parent element, if any.\n  var using = opt_parentElement || document,\n      buttons = using.querySelectorAll('button');\n\n  // Return an array of buttons with the text.\n  return Array.prototype.filter.call(buttons, function(button) {\n    return button.textContent === buttonText;\n  });\n});\n\n// Use the custom locator.\nelement(by.buttonTextSimple('Go!')).click();",
    "fileName": "locators",
    "htmlView": "&lt;button ng-click=&quot;doAddition()&quot;&gt;Go!&lt;/button&gt;",
    "name": "ProtractorBy.prototype.addLocator",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The name of the new locator.",
        "startingLine": 75,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "name",
        "paramString": "string"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "A script to be run in the context of the browser. This script will be passed an array of arguments that contains any args passed into the locator followed by the element scoping the search and the css selector for the root angular element. It should return an array of elements.",
        "startingLine": 76,
        "typeExpression": "Function|string",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "FunctionType",
              "params": []
            },
            {
              "type": "NameExpression",
              "name": "string"
            }
          ]
        },
        "typeList": [
          "function()",
          "string"
        ],
        "name": "script",
        "paramString": "Function&#124;string"
      }
    ],
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts",
    "view": "<button ng-click=\"doAddition()\">Go!</button>"
  },
  {
    "description": "<p>Find an element by text binding. Does a partial match, so any elements\nbound to variables containing the input string will be returned.</p>\n<p>Note: For AngularJS version 1.2, the interpolation brackets, (usually\n{{}}), are optionally allowed in the binding description string. For\nAngular version 1.3+, they are not allowed, and no elements will be found\nif they are used.</p>\n",
    "example": "var span1 = element(by.binding('person.name'));\nexpect(span1.getText()).toBe('Foo');\n\nvar span2 = element(by.binding('person.email'));\nexpect(span2.getText()).toBe('foo@bar.com');\n\n// You can also use a substring for a partial match\nvar span1alt = element(by.binding('name'));\nexpect(span1alt.getText()).toBe('Foo');\n\n// This works for sites using Angular 1.2 but NOT 1.3\nvar deprecatedSyntax = element(by.binding('{{person.name}}'));",
    "fileName": "locators",
    "htmlView": "&lt;span&gt;{{person.name}}&lt;/span&gt;\n&lt;span ng-bind=&quot;person.email&quot;&gt;&lt;/span&gt;",
    "name": "ProtractorBy.prototype.binding",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 133,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "bindingDescriptor",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "location strategy",
      "startingLine": 134,
      "typeExpression": "ProtractorLocator",
      "type": {
        "type": "NameExpression",
        "name": "ProtractorLocator"
      },
      "typeList": [
        "ProtractorLocator"
      ]
    },
    "returnString": "ProtractorLocator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts",
    "view": "<span>{{person.name}}</span>\n<span ng-bind=\"person.email\"></span>"
  },
  {
    "description": "<p>Find an element by exact binding.</p>\n",
    "example": "expect(element(by.exactBinding('person.name')).isPresent()).toBe(true);\nexpect(element(by.exactBinding('person-email')).isPresent()).toBe(true);\nexpect(element(by.exactBinding('person')).isPresent()).toBe(false);\nexpect(element(by.exactBinding('person_phone')).isPresent()).toBe(true);\nexpect(element(by.exactBinding('person_phone|uppercase')).isPresent()).toBe(true);\nexpect(element(by.exactBinding('phone')).isPresent()).toBe(false);",
    "fileName": "locators",
    "htmlView": "&lt;span&gt;{{ person.name }}&lt;/span&gt;\n&lt;span ng-bind=&quot;person-email&quot;&gt;&lt;/span&gt;\n&lt;span&gt;{{person_phone|uppercase}}&lt;/span&gt;",
    "name": "ProtractorBy.prototype.exactBinding",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 163,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "bindingDescriptor",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "location strategy",
      "startingLine": 164,
      "typeExpression": "ProtractorLocator",
      "type": {
        "type": "NameExpression",
        "name": "ProtractorLocator"
      },
      "typeList": [
        "ProtractorLocator"
      ]
    },
    "returnString": "ProtractorLocator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts",
    "view": "<span>{{ person.name }}</span>\n<span ng-bind=\"person-email\"></span>\n<span>{{person_phone|uppercase}}</span>"
  },
  {
    "alias": "by.model(modelName)",
    "description": "<p>Find an element by ng-model expression.</p>\n",
    "example": "var input = element(by.model('person.name'));\ninput.sendKeys('123');\nexpect(input.getAttribute('value')).toBe('Foo123');",
    "fileName": "locators",
    "htmlView": "&lt;input type=&quot;text&quot; ng-model=&quot;person.name&quot;&gt;",
    "name": "ProtractorBy.prototype.model",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "ng-model expression.",
        "startingLine": 189,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "model",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "location strategy",
      "startingLine": 190,
      "typeExpression": "ProtractorLocator",
      "type": {
        "type": "NameExpression",
        "name": "ProtractorLocator"
      },
      "typeList": [
        "ProtractorLocator"
      ]
    },
    "returnString": "ProtractorLocator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts",
    "view": "<input type=\"text\" ng-model=\"person.name\">"
  },
  {
    "description": "<p>Find a button by text.</p>\n",
    "example": "element(by.buttonText('Save'));",
    "fileName": "locators",
    "htmlView": "&lt;button&gt;Save&lt;/button&gt;",
    "name": "ProtractorBy.prototype.buttonText",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 212,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "searchText",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "location strategy",
      "startingLine": 213,
      "typeExpression": "ProtractorLocator",
      "type": {
        "type": "NameExpression",
        "name": "ProtractorLocator"
      },
      "typeList": [
        "ProtractorLocator"
      ]
    },
    "returnString": "ProtractorLocator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts",
    "view": "<button>Save</button>"
  },
  {
    "description": "<p>Find a button by partial text.</p>\n",
    "example": "element(by.partialButtonText('Save'));",
    "fileName": "locators",
    "htmlView": "&lt;button&gt;Save my file&lt;/button&gt;",
    "name": "ProtractorBy.prototype.partialButtonText",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 235,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "searchText",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "location strategy",
      "startingLine": 236,
      "typeExpression": "ProtractorLocator",
      "type": {
        "type": "NameExpression",
        "name": "ProtractorLocator"
      },
      "typeList": [
        "ProtractorLocator"
      ]
    },
    "returnString": "ProtractorLocator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts",
    "view": "<button>Save my file</button>"
  },
  {
    "description": "<p>Find elements inside an ng-repeat.</p>\n",
    "example": "// Returns the DIV for the second cat.\nvar secondCat = element(by.repeater('cat in pets').row(1));\n\n// Returns the SPAN for the first cat's name.\nvar firstCatName = element(by.repeater('cat in pets').\n    row(0).column('cat.name'));\n\n// Returns a promise that resolves to an array of WebElements from a column\nvar ages = element.all(\n    by.repeater('cat in pets').column('cat.age'));\n\n// Returns a promise that resolves to an array of WebElements containing\n// all top level elements repeated by the repeater. For 2 pets rows\n// resolves to an array of 2 elements.\nvar rows = element.all(by.repeater('cat in pets'));\n\n// Returns a promise that resolves to an array of WebElements containing\n// all the elements with a binding to the book's name.\nvar divs = element.all(by.repeater('book in library').column('book.name'));\n\n// Returns a promise that resolves to an array of WebElements containing\n// the DIVs for the second book.\nvar bookInfo = element.all(by.repeater('book in library').row(1));\n\n// Returns the H4 for the first book's name.\nvar firstBookName = element(by.repeater('book in library').\n    row(0).column('book.name'));\n\n// Returns a promise that resolves to an array of WebElements containing\n// all top level elements repeated by the repeater. For 2 books divs\n// resolves to an array of 4 elements.\nvar divs = element.all(by.repeater('book in library'));",
    "fileName": "locators",
    "htmlView": "&lt;div ng-repeat=&quot;cat in pets&quot;&gt;\n  &lt;span&gt;{{cat.name}}&lt;/span&gt;\n  &lt;span&gt;{{cat.age}}&lt;/span&gt;\n&lt;/div&gt;\n\n&lt;div class=&quot;book-img&quot; ng-repeat-start=&quot;book in library&quot;&gt;\n  &lt;span&gt;{{$index}}&lt;/span&gt;\n&lt;/div&gt;\n&lt;div class=&quot;book-info&quot; ng-repeat-end&gt;\n  &lt;h4&gt;{{book.name}}&lt;/h4&gt;\n  &lt;p&gt;{{book.blurb}}&lt;/p&gt;\n&lt;/div&gt;",
    "name": "ProtractorBy.prototype.repeater",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 354,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "repeatDescriptor",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "location strategy",
      "startingLine": 355,
      "typeExpression": "ProtractorLocator",
      "type": {
        "type": "NameExpression",
        "name": "ProtractorLocator"
      },
      "typeList": [
        "ProtractorLocator"
      ]
    },
    "returnString": "ProtractorLocator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts",
    "view": "<div ng-repeat=\"cat in pets\">\n  <span>{{cat.name}}</span>\n  <span>{{cat.age}}</span>\n</div>\n\n<div class=\"book-img\" ng-repeat-start=\"book in library\">\n  <span>{{$index}}</span>\n</div>\n<div class=\"book-info\" ng-repeat-end>\n  <h4>{{book.name}}</h4>\n  <p>{{book.blurb}}</p>\n</div>"
  },
  {
    "description": "<p>Find an element by exact repeater.</p>\n",
    "example": "expect(element(by.exactRepeater('person in\npeopleWithRedHair')).isPresent())\n    .toBe(true);\nexpect(element(by.exactRepeater('person in\npeople')).isPresent()).toBe(false);\nexpect(element(by.exactRepeater('car in cars')).isPresent()).toBe(true);",
    "fileName": "locators",
    "htmlView": "&lt;li ng-repeat=&quot;person in peopleWithRedHair&quot;&gt;&lt;/li&gt;\n&lt;li ng-repeat=&quot;car in cars | orderBy:year&quot;&gt;&lt;/li&gt;",
    "name": "ProtractorBy.prototype.exactRepeater",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 375,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "repeatDescriptor",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "location strategy",
      "startingLine": 376,
      "typeExpression": "ProtractorLocator",
      "type": {
        "type": "NameExpression",
        "name": "ProtractorLocator"
      },
      "typeList": [
        "ProtractorLocator"
      ]
    },
    "returnString": "ProtractorLocator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts",
    "view": "<li ng-repeat=\"person in peopleWithRedHair\"></li>\n<li ng-repeat=\"car in cars | orderBy:year\"></li>"
  },
  {
    "description": "<p>Find elements by CSS which contain a certain string.</p>\n",
    "example": "// Returns the li for the dog, but not cat.\nvar dog = element(by.cssContainingText('.pet', 'Dog'));",
    "fileName": "locators",
    "htmlView": "&lt;ul&gt;\n  &lt;li class=&quot;pet&quot;&gt;Dog&lt;/li&gt;\n  &lt;li class=&quot;pet&quot;&gt;Cat&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "ProtractorBy.prototype.cssContainingText",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "css selector",
        "startingLine": 394,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "cssSelector",
        "paramString": "string"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "text search",
        "startingLine": 395,
        "typeExpression": "string|RegExp",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "NameExpression",
              "name": "RegExp"
            }
          ]
        },
        "typeList": [
          "string",
          "RegExp"
        ],
        "name": "searchString",
        "paramString": "string&#124;RegExp"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "location strategy",
      "startingLine": 396,
      "typeExpression": "ProtractorLocator",
      "type": {
        "type": "NameExpression",
        "name": "ProtractorLocator"
      },
      "typeList": [
        "ProtractorLocator"
      ]
    },
    "returnString": "ProtractorLocator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts",
    "view": "<ul>\n  <li class=\"pet\">Dog</li>\n  <li class=\"pet\">Cat</li>\n</ul>"
  },
  {
    "alias": "by.options(optionsDescriptor)",
    "description": "<p>Find an element by ng-options expression.</p>\n",
    "example": "var allOptions = element.all(by.options('c for c in colors'));\nexpect(allOptions.count()).toEqual(2);\nvar firstOption = allOptions.first();\nexpect(firstOption.getText()).toEqual('red');",
    "fileName": "locators",
    "htmlView": "&lt;select ng-model=&quot;color&quot; ng-options=&quot;c for c in colors&quot;&gt;\n  &lt;option value=&quot;0&quot; selected=&quot;selected&quot;&gt;red&lt;/option&gt;\n  &lt;option value=&quot;1&quot;&gt;green&lt;/option&gt;\n&lt;/select&gt;",
    "name": "ProtractorBy.prototype.options",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "ng-options expression.",
        "startingLine": 426,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "optionsDescriptor",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "location strategy",
      "startingLine": 427,
      "typeExpression": "ProtractorLocator",
      "type": {
        "type": "NameExpression",
        "name": "ProtractorLocator"
      },
      "typeList": [
        "ProtractorLocator"
      ]
    },
    "returnString": "ProtractorLocator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts",
    "view": "<select ng-model=\"color\" ng-options=\"c for c in colors\">\n  <option value=\"0\" selected=\"selected\">red</option>\n  <option value=\"1\">green</option>\n</select>"
  },
  {
    "alias": "by.deepCss(selector)",
    "description": "<p>Find an element by css selector within the Shadow DOM.</p>\n",
    "example": "var spans = element.all(by.deepCss('span'));\nexpect(spans.count()).toEqual(3);",
    "fileName": "locators",
    "htmlView": "&lt;div&gt;\n  &lt;span id=&quot;outerspan&quot;&gt;\n  &lt;&quot;shadow tree&quot;&gt;\n    &lt;span id=&quot;span1&quot;&gt;&lt;/span&gt;\n    &lt;&quot;shadow tree&quot;&gt;\n      &lt;span id=&quot;span2&quot;&gt;&lt;/span&gt;\n    &lt;/&gt;\n  &lt;/&gt;\n&lt;/div&gt;",
    "name": "ProtractorBy.prototype.deepCss",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "a css selector within the Shadow DOM.",
        "startingLine": 458,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "selector",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "location strategy",
      "startingLine": 459,
      "typeExpression": "Locator",
      "type": {
        "type": "NameExpression",
        "name": "Locator"
      },
      "typeList": [
        "Locator"
      ]
    },
    "returnString": "Locator",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/locators.ts",
    "view": "<div>\n  <span id=\"outerspan\">\n  <\"shadow tree\">\n    <span id=\"span1\"></span>\n    <\"shadow tree\">\n      <span id=\"span2\"></span>\n    </>\n  </>\n</div>"
  },
  {
    "alias": "ExpectedConditions",
    "description": "<p>Represents a library of canned expected conditions that are useful for\nprotractor, especially when dealing with non-angular apps.</p>\n<p>Each condition returns a function that evaluates to a promise. You may mix\nmultiple conditions using <code>and</code>, <code>or</code>, and/or <code>not</code>. You may also\nmix these conditions with any other conditions that you write.</p>\n<p>See ExpectedCondition Class in Selenium WebDriver codebase.\n<a href=\"http://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html\">http://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html</a></p>\n",
    "example": "var EC = protractor.ExpectedConditions;\nvar button = $('#xyz');\nvar isClickable = EC.elementToBeClickable(button);\n\nbrowser.get(URL);\nbrowser.wait(isClickable, 5000); //wait for an element to become clickable\nbutton.click();\n\n// You can define your own expected condition, which is a function that\n// takes no parameter and evaluates to a promise of a boolean.\nvar urlChanged = function() {\n  return browser.getCurrentUrl().then(function(url) {\n    return url === 'http://www.angularjs.org';\n  });\n};\n\n// You can customize the conditions with EC.and, EC.or, and EC.not.\n// Here's a condition to wait for url to change, $('abc') element to contain\n// text 'bar', and button becomes clickable.\nvar condition = EC.and(urlChanged, EC.textToBePresentInElement($('abc'),\n'bar'), isClickable);\nbrowser.get(URL);\nbrowser.wait(condition, 5000); //wait for condition to be true.\nbutton.click();",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions",
    "returnString": "",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.not",
    "description": "<p>Negates the result of a promise.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\nvar titleIsNotFoo = EC.not(EC.titleIs('Foo'));\n// Waits for title to become something besides 'foo'.\nbrowser.wait(titleIsNotFoo, 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.not",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 60,
        "typeExpression": "!function",
        "type": {
          "type": "FunctionType",
          "params": [],
          "nullable": false
        },
        "typeList": [
          "!function"
        ],
        "name": "expectedCondition",
        "paramString": "!function"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns the negated value.",
      "startingLine": 62,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.and",
    "description": "<p>Chain a number of expected conditions using logical_and, short circuiting\nat the first expected condition that evaluates to false.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\nvar titleContainsFoo = EC.titleContains('Foo');\nvar titleIsNotFooBar = EC.not(EC.titleIs('FooBar'));\n// Waits for title to contain 'Foo', but is not 'FooBar'\nbrowser.wait(EC.and(titleContainsFoo, titleIsNotFooBar), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.and",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "An array of expected conditions to 'and'\ntogether.",
        "startingLine": 111,
        "typeExpression": "Array.<Function>",
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "FunctionType",
              "params": []
            }
          ]
        },
        "typeList": [
          "Array.<Function>"
        ],
        "name": "fns",
        "paramString": "Array.&lt;Function&gt;"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise which evaluates to the result of the logical and.",
      "startingLine": 114,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.or",
    "description": "<p>Chain a number of expected conditions using logical_or, short circuiting\nat the first expected condition that evaluates to true.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\nvar titleContainsFoo = EC.titleContains('Foo');\nvar titleContainsBar = EC.titleContains('Bar');\n// Waits for title to contain either 'Foo' or 'Bar'\nbrowser.wait(EC.or(titleContainsFoo, titleContainsBar), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.or",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "An array of expected conditions to 'or'\ntogether.",
        "startingLine": 136,
        "typeExpression": "Array.<Function>",
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "FunctionType",
              "params": []
            }
          ]
        },
        "typeList": [
          "Array.<Function>"
        ],
        "name": "fns",
        "paramString": "Array.&lt;Function&gt;"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise which evaluates to the result of the logical or.",
      "startingLine": 139,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.alertIsPresent",
    "description": "<p>Expect an alert to be present.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for an alert pops up.\nbrowser.wait(EC.alertIsPresent(), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.alertIsPresent",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether an alert is present.",
      "startingLine": 158,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.elementToBeClickable",
    "description": "<p>An Expectation for checking an element is visible and enabled such that you\ncan click it.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the element with id 'abc' to be clickable.\nbrowser.wait(EC.elementToBeClickable($('#abc')), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.elementToBeClickable",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The element to check",
        "startingLine": 186,
        "typeExpression": "!ElementFinder",
        "type": {
          "type": "NameExpression",
          "name": "ElementFinder",
          "nullable": false
        },
        "typeList": [
          "ElementFinder"
        ],
        "name": "elementFinder",
        "paramString": "&#33;[ElementFinder](ElementFinder)"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the element is clickable.",
      "startingLine": 188,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.textToBePresentInElement",
    "description": "<p>An expectation for checking if the given text is present in the\nelement. Returns false if the elementFinder does not find an element.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the element with id 'abc' to contain the text 'foo'.\nbrowser.wait(EC.textToBePresentInElement($('#abc'), 'foo'), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.textToBePresentInElement",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The element to check",
        "startingLine": 206,
        "typeExpression": "!ElementFinder",
        "type": {
          "type": "NameExpression",
          "name": "ElementFinder",
          "nullable": false
        },
        "typeList": [
          "ElementFinder"
        ],
        "name": "elementFinder",
        "paramString": "&#33;[ElementFinder](ElementFinder)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The text to verify against",
        "startingLine": 207,
        "typeExpression": "!string",
        "type": {
          "type": "NameExpression",
          "name": "string",
          "nullable": false
        },
        "typeList": [
          "string"
        ],
        "name": "text",
        "paramString": "!string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the text is present in the element.",
      "startingLine": 209,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.textToBePresentInElement",
    "description": "<p>An expectation for checking if the given text is present in the element’s\nvalue. Returns false if the elementFinder does not find an element.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the element with id 'myInput' to contain the input 'foo'.\nbrowser.wait(EC.textToBePresentInElementValue($('#myInput'), 'foo'), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.textToBePresentInElementValue",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The element to check",
        "startingLine": 232,
        "typeExpression": "!ElementFinder",
        "type": {
          "type": "NameExpression",
          "name": "ElementFinder",
          "nullable": false
        },
        "typeList": [
          "ElementFinder"
        ],
        "name": "elementFinder",
        "paramString": "&#33;[ElementFinder](ElementFinder)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The text to verify against",
        "startingLine": 233,
        "typeExpression": "!string",
        "type": {
          "type": "NameExpression",
          "name": "string",
          "nullable": false
        },
        "typeList": [
          "string"
        ],
        "name": "text",
        "paramString": "!string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the text is present in the element's value.",
      "startingLine": 235,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.titleContains",
    "description": "<p>An expectation for checking that the title contains a case-sensitive\nsubstring.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the title to contain 'foo'.\nbrowser.wait(EC.titleContains('foo'), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.titleContains",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The fragment of title expected",
        "startingLine": 256,
        "typeExpression": "!string",
        "type": {
          "type": "NameExpression",
          "name": "string",
          "nullable": false
        },
        "typeList": [
          "string"
        ],
        "name": "title",
        "paramString": "!string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the title contains the string.",
      "startingLine": 258,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.titleIs",
    "description": "<p>An expectation for checking the title of a page.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the title to be 'foo'.\nbrowser.wait(EC.titleIs('foo'), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.titleIs",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The expected title, which must be an exact match.",
        "startingLine": 278,
        "typeExpression": "!string",
        "type": {
          "type": "NameExpression",
          "name": "string",
          "nullable": false
        },
        "typeList": [
          "string"
        ],
        "name": "title",
        "paramString": "!string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the title equals the string.",
      "startingLine": 280,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.urlContains",
    "description": "<p>An expectation for checking that the URL contains a case-sensitive\nsubstring.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the URL to contain 'foo'.\nbrowser.wait(EC.urlContains('foo'), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.urlContains",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The fragment of URL expected",
        "startingLine": 301,
        "typeExpression": "!string",
        "type": {
          "type": "NameExpression",
          "name": "string",
          "nullable": false
        },
        "typeList": [
          "string"
        ],
        "name": "url",
        "paramString": "!string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the URL contains the string.",
      "startingLine": 303,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.urlIs",
    "description": "<p>An expectation for checking the URL of a page.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the URL to be 'foo'.\nbrowser.wait(EC.urlIs('foo'), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.urlIs",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The expected URL, which must be an exact match.",
        "startingLine": 323,
        "typeExpression": "!string",
        "type": {
          "type": "NameExpression",
          "name": "string",
          "nullable": false
        },
        "typeList": [
          "string"
        ],
        "name": "url",
        "paramString": "!string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the url equals the string.",
      "startingLine": 325,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.presenceOf",
    "description": "<p>An expectation for checking that an element is present on the DOM\nof a page. This does not necessarily mean that the element is visible.\nThis is the opposite of &#39;stalenessOf&#39;.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the element with id 'abc' to be present on the dom.\nbrowser.wait(EC.presenceOf($('#abc')), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.presenceOf",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The element to check",
        "startingLine": 347,
        "typeExpression": "!ElementFinder",
        "type": {
          "type": "NameExpression",
          "name": "ElementFinder",
          "nullable": false
        },
        "typeList": [
          "ElementFinder"
        ],
        "name": "elementFinder",
        "paramString": "&#33;[ElementFinder](ElementFinder)"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the element is present.",
      "startingLine": 349,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.stalenessOf",
    "description": "<p>An expectation for checking that an element is not attached to the DOM\nof a page. This is the opposite of &#39;presenceOf&#39;.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the element with id 'abc' to be no longer present on the dom.\nbrowser.wait(EC.stalenessOf($('#abc')), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.stalenessOf",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The element to check",
        "startingLine": 366,
        "typeExpression": "!ElementFinder",
        "type": {
          "type": "NameExpression",
          "name": "ElementFinder",
          "nullable": false
        },
        "typeList": [
          "ElementFinder"
        ],
        "name": "elementFinder",
        "paramString": "&#33;[ElementFinder](ElementFinder)"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the element is stale.",
      "startingLine": 368,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.visibilityOf",
    "description": "<p>An expectation for checking that an element is present on the DOM of a\npage and visible. Visibility means that the element is not only displayed\nbut also has a height and width that is greater than 0. This is the\nopposite\nof &#39;invisibilityOf&#39;.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the element with id 'abc' to be visible on the dom.\nbrowser.wait(EC.visibilityOf($('#abc')), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.visibilityOf",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The element to check",
        "startingLine": 387,
        "typeExpression": "!ElementFinder",
        "type": {
          "type": "NameExpression",
          "name": "ElementFinder",
          "nullable": false
        },
        "typeList": [
          "ElementFinder"
        ],
        "name": "elementFinder",
        "paramString": "&#33;[ElementFinder](ElementFinder)"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the element is visible.",
      "startingLine": 389,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.invisibilityOf",
    "description": "<p>An expectation for checking that an element is either invisible or not\npresent on the DOM. This is the opposite of &#39;visibilityOf&#39;.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the element with id 'abc' to be no longer visible on the dom.\nbrowser.wait(EC.invisibilityOf($('#abc')), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.invisibilityOf",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The element to check",
        "startingLine": 407,
        "typeExpression": "!ElementFinder",
        "type": {
          "type": "NameExpression",
          "name": "ElementFinder",
          "nullable": false
        },
        "typeList": [
          "ElementFinder"
        ],
        "name": "elementFinder",
        "paramString": "&#33;[ElementFinder](ElementFinder)"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the element is invisible.",
      "startingLine": 409,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "alias": "ExpectedConditions.elementToBeSelected",
    "description": "<p>An expectation for checking the selection is selected.</p>\n",
    "example": "var EC = protractor.ExpectedConditions;\n// Waits for the element with id 'myCheckbox' to be selected.\nbrowser.wait(EC.elementToBeSelected($('#myCheckbox')), 5000);",
    "fileName": "expectedConditions",
    "name": "ProtractorExpectedConditions.prototype.elementToBeSelected",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The element to check",
        "startingLine": 424,
        "typeExpression": "!ElementFinder",
        "type": {
          "type": "NameExpression",
          "name": "ElementFinder",
          "nullable": false
        },
        "typeList": [
          "ElementFinder"
        ],
        "name": "elementFinder",
        "paramString": "&#33;[ElementFinder](ElementFinder)"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "An expected condition that returns a promise representing whether the element is selected.",
      "startingLine": 426,
      "typeExpression": "!function",
      "type": {
        "type": "FunctionType",
        "params": [],
        "nullable": false
      },
      "typeList": [
        "!function"
      ]
    },
    "returnString": "!function",
    "sourceLink": "https://github.com/angular/protractor/blob/5.3.1/lib/expectedConditions.ts"
  },
  {
    "description": "<p>A collection of factory functions for creating <code ng-non-bindable>webdriver.Locator</code>\ninstances.</p>\n",
    "fileName": "locators",
    "name": "webdriver.By",
    "returnString": ""
  },
  {
    "description": "<p>Locates elements that have a specific class name. The returned locator\nis equivalent to searching for elements with the CSS selector &quot;.clazz&quot;.</p>\n<br />See [<code ng-non-bindable>http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;2011&#x2F;WD-html5-20110525&#x2F;elements.html#classes</code>](http://www.w3.org/TR/2011/WD-html5-20110525/elements.html#classes)<br />See [<code ng-non-bindable>http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;CSS2&#x2F;selector.html#class-html</code>](http://www.w3.org/TR/CSS2/selector.html#class-html)",
    "example": "// Returns the web element for dog\nvar dog = element(by.className('dog'));\nexpect(dog.getText()).toBe('Dog');",
    "fileName": "locators",
    "htmlView": "&lt;ul class=&quot;pet&quot;&gt;\n  &lt;li class=&quot;dog&quot;&gt;Dog&lt;/li&gt;\n  &lt;li class=&quot;cat&quot;&gt;Cat&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "webdriver.By.className",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The class name to search for.",
        "startingLine": 30,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "className",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The new locator.",
      "startingLine": 31,
      "typeExpression": "!webdriver.Locator",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.Locator",
        "nullable": false
      },
      "typeList": [
        "webdriver.Locator"
      ]
    },
    "returnString": "!webdriver.Locator",
    "view": "<ul class=\"pet\">\n  <li class=\"dog\">Dog</li>\n  <li class=\"cat\">Cat</li>\n</ul>"
  },
  {
    "description": "<p>Locates elements using a CSS selector. For browsers that do not support\nCSS selectors, WebDriver implementations may return an\ninvalid selector error. An\nimplementation may, however, emulate the CSS selector API.</p>\n<br />See [<code ng-non-bindable>http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;CSS2&#x2F;selector.html</code>](http://www.w3.org/TR/CSS2/selector.html)",
    "example": "// Returns the web element for cat\nvar cat = element(by.css('.pet .cat'));\nexpect(cat.getText()).toBe('Cat');",
    "fileName": "locators",
    "htmlView": "&lt;ul class=&quot;pet&quot;&gt;\n  &lt;li class=&quot;dog&quot;&gt;Dog&lt;/li&gt;\n  &lt;li class=&quot;cat&quot;&gt;Cat&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "webdriver.By.css",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The CSS selector to use.",
        "startingLine": 55,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "selector",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The new locator.",
      "startingLine": 56,
      "typeExpression": "!webdriver.Locator",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.Locator",
        "nullable": false
      },
      "typeList": [
        "webdriver.Locator"
      ]
    },
    "returnString": "!webdriver.Locator",
    "view": "<ul class=\"pet\">\n  <li class=\"dog\">Dog</li>\n  <li class=\"cat\">Cat</li>\n</ul>"
  },
  {
    "description": "<p>Locates an element by its ID.</p>\n",
    "example": "// Returns the web element for dog\nvar dog = element(by.id('dog_id'));\nexpect(dog.getText()).toBe('Dog');",
    "fileName": "locators",
    "htmlView": "&lt;ul id=&quot;pet_id&quot;&gt;\n  &lt;li id=&quot;dog_id&quot;&gt;Dog&lt;/li&gt;\n  &lt;li id=&quot;cat_id&quot;&gt;Cat&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "webdriver.By.id",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The ID to search for.",
        "startingLine": 76,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "id",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The new locator.",
      "startingLine": 77,
      "typeExpression": "!webdriver.Locator",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.Locator",
        "nullable": false
      },
      "typeList": [
        "webdriver.Locator"
      ]
    },
    "returnString": "!webdriver.Locator",
    "view": "<ul id=\"pet_id\">\n  <li id=\"dog_id\">Dog</li>\n  <li id=\"cat_id\">Cat</li>\n</ul>"
  },
  {
    "description": "<p>Locates link elements whose [visible text](webdriver.WebElement.prototype.getText) matches the given string.</p>\n",
    "example": "expect(element(by.linkText('Google')).getTagName()).toBe('a');",
    "fileName": "locators",
    "htmlView": "&lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;",
    "name": "webdriver.By.linkText",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The link text to search for.",
        "startingLine": 92,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "text",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The new locator.",
      "startingLine": 93,
      "typeExpression": "!webdriver.Locator",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.Locator",
        "nullable": false
      },
      "typeList": [
        "webdriver.Locator"
      ]
    },
    "returnString": "!webdriver.Locator",
    "view": "<a href=\"http://www.google.com\">Google</a>"
  },
  {
    "alias": "by.js(expression)",
    "description": "<p>Locates an elements by evaluating a JavaScript expression, which may\nbe either a function or a string. Like\n<code ng-non-bindable>webdriver.WebDriver.executeScript</code>, the expression is evaluated\nin the context of the page and cannot access variables from\nthe test file.</p>\n<p>The result of this expression must be an element or list of elements.</p>\n",
    "example": "var wideElement = element(by.js(function() {\n  var spans = document.querySelectorAll('span');\n  for (var i = 0; i < spans.length; ++i) {\n    if (spans[i].offsetWidth > 100) {\n     return spans[i];\n    }\n  }\n}));\nexpect(wideElement.getText()).toEqual('Three');",
    "fileName": "locators",
    "htmlView": "&lt;span class=&quot;small&quot;&gt;One&lt;/span&gt;\n&lt;span class=&quot;medium&quot;&gt;Two&lt;/span&gt;\n&lt;span class=&quot;large&quot;&gt;Three&lt;/span&gt;",
    "name": "webdriver.By.js",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The script to execute.",
        "startingLine": 124,
        "typeExpression": "!(string|Function)",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "FunctionType",
              "params": []
            }
          ],
          "nullable": false
        },
        "typeList": [
          "string",
          "function()"
        ],
        "name": "script",
        "paramString": "!(string&#124;Function)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The arguments to pass to the script.",
        "startingLine": 125,
        "typeExpression": "...*",
        "type": {
          "type": "AllLiteral",
          "repeatable": true
        },
        "typeList": [
          "*"
        ],
        "name": "var_args",
        "paramString": "...*"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 126,
      "typeExpression": "!webdriver.Locator",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.Locator",
        "nullable": false
      },
      "typeList": [
        "webdriver.Locator"
      ]
    },
    "returnString": "!webdriver.Locator",
    "view": "<span class=\"small\">One</span>\n<span class=\"medium\">Two</span>\n<span class=\"large\">Three</span>"
  },
  {
    "description": "<p>Locates elements whose <code ng-non-bindable>name</code> attribute has the given value.</p>\n",
    "example": "// Returns the web element for dog\nvar dog = element(by.name('dog_name'));\nexpect(dog.getText()).toBe('Dog');",
    "fileName": "locators",
    "htmlView": "&lt;ul&gt;\n  &lt;li name=&quot;dog_name&quot;&gt;Dog&lt;/li&gt;\n  &lt;li name=&quot;cat_name&quot;&gt;Cat&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "webdriver.By.name",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The name attribute to search for.",
        "startingLine": 145,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "name",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The new locator.",
      "startingLine": 146,
      "typeExpression": "!webdriver.Locator",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.Locator",
        "nullable": false
      },
      "typeList": [
        "webdriver.Locator"
      ]
    },
    "returnString": "!webdriver.Locator",
    "view": "<ul>\n  <li name=\"dog_name\">Dog</li>\n  <li name=\"cat_name\">Cat</li>\n</ul>"
  },
  {
    "description": "<p>Locates link elements whose [visible text](webdriver.WebElement.prototype.getText) contains the given substring.</p>\n",
    "example": "// Returns the 'a' web element for doge meme and navigate to that link\nvar doge = element(by.partialLinkText('Doge'));\ndoge.click();",
    "fileName": "locators",
    "htmlView": "&lt;ul&gt;\n  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Doge_(meme)&quot;&gt;Doge meme&lt;/a&gt;&lt;/li&gt;\n  &lt;li&gt;Cat&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "webdriver.By.partialLinkText",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The substring to check for in a link's visible text.",
        "startingLine": 166,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "text",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The new locator.",
      "startingLine": 167,
      "typeExpression": "!webdriver.Locator",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.Locator",
        "nullable": false
      },
      "typeList": [
        "webdriver.Locator"
      ]
    },
    "returnString": "!webdriver.Locator",
    "view": "<ul>\n  <li><a href=\"https://en.wikipedia.org/wiki/Doge_(meme)\">Doge meme</a></li>\n  <li>Cat</li>\n</ul>"
  },
  {
    "description": "<p>Locates elements with a given tag name. The returned locator is\nequivalent to using the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element.getElementsByTagName\">getElementsByTagName</a>\nDOM function.</p>\n<br />See [<code ng-non-bindable>http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;REC-DOM-Level-1&#x2F;level-one-core.html</code>](http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html)",
    "example": "expect(element(by.tagName('a')).getText()).toBe('Google');",
    "fileName": "locators",
    "htmlView": "&lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;",
    "name": "webdriver.By.tagName",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The substring to check for in a link's visible text.",
        "startingLine": 185,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "text",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The new locator.",
      "startingLine": 186,
      "typeExpression": "!webdriver.Locator",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.Locator",
        "nullable": false
      },
      "typeList": [
        "webdriver.Locator"
      ]
    },
    "returnString": "!webdriver.Locator",
    "view": "<a href=\"http://www.google.com\">Google</a>"
  },
  {
    "description": "<p>Locates elements matching a XPath selector. Care should be taken when\nusing an XPath selector with a [<code ng-non-bindable>webdriver.WebElement</code>](webdriver.WebElement) as WebDriver\nwill respect the context in the specified in the selector. For example,\ngiven the selector <code ng-non-bindable>&amp;quot;&#x2F;&#x2F;div&amp;quot;</code>, WebDriver will search from the\ndocument root regardless of whether the locator was used with a\nWebElement.</p>\n<br />See [<code ng-non-bindable>http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xpath&#x2F;</code>](http://www.w3.org/TR/xpath/)",
    "example": "// Returns the 'a' element for doge meme\nvar li = element(by.xpath('//ul/li/a'));\nexpect(li.getText()).toBe('Doge meme');",
    "fileName": "locators",
    "htmlView": "&lt;ul&gt;\n  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Doge_(meme)&quot;&gt;Doge meme&lt;/a&gt;&lt;/li&gt;\n  &lt;li&gt;Cat&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "webdriver.By.xpath",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The XPath selector to use.",
        "startingLine": 211,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "xpath",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The new locator.",
      "startingLine": 212,
      "typeExpression": "!webdriver.Locator",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.Locator",
        "nullable": false
      },
      "typeList": [
        "webdriver.Locator"
      ]
    },
    "returnString": "!webdriver.Locator",
    "view": "<ul>\n  <li><a href=\"https://en.wikipedia.org/wiki/Doge_(meme)\">Doge meme</a></li>\n  <li>Cat</li>\n</ul>"
  },
  {
    "description": "<p>Protractor&#39;s <code>browser</code> object is a wrapper for <code>selenium-webdriver</code> WebDriver.\nIt inherits call of WebDriver&#39;s methods, but only the methods most useful to\nProtractor users are documented here.</p>\n<p>A full list of all functions available on WebDriver can be found\nin the selenium-webdriver\n<a href=\"http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/webdriver_exports_WebDriver.html\">documentation</a></p>\n",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver",
    "returnString": ""
  },
  {
    "description": "<p>Creates a sequence of user actions using this driver. The sequence will not be\nscheduled for execution until <code ng-non-bindable>webdriver.ActionSequence#perform</code> is\ncalled.</p>\n<p>See the selenium webdriver docs <a href=\"http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/actions_exports_ActionSequence.html\">\nfor more details on action sequences</a>.</p>\n<p>Mouse actions do not work on Chrome with the HTML5 Drag and Drop API due to a known <a href=\"https://bugs.chromium.org/p/chromedriver/issues/detail?id=841\">\n  Chromedriver issue</a></p>\n",
    "example": "// Dragging one element to another.\nbrowser.actions().\n    mouseDown(element1).\n    mouseMove(element2).\n    mouseUp().\n    perform();\n\n// You can also use the `dragAndDrop` convenience action.\nbrowser.actions().\n    dragAndDrop(element1, element2).\n    perform();\n\n// Instead of specifying an element as the target, you can specify an offset\n// in pixels. This example double-clicks slightly to the right of an element.\nbrowser.actions().\n    mouseMove(element).\n    mouseMove({x: 50, y: 0}).\n    doubleClick().\n    perform();",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.actions",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A new action sequence for this instance.",
      "startingLine": 72,
      "typeExpression": "!webdriver.ActionSequence",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.ActionSequence",
        "nullable": false
      },
      "typeList": [
        "webdriver.ActionSequence"
      ]
    },
    "returnString": "&#33;[webdriver.ActionSequence](http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/actions_exports_ActionSequence.html)"
  },
  {
    "description": "<p>Creates a new touch sequence using this driver. The sequence will not be\nscheduled for execution until <code ng-non-bindable>actions.TouchSequence#perform</code> is\ncalled.</p>\n<p>See the selenium webdriver docs <a href=\"http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/index_exports_TouchSequence.html\">\nfor more details on touch sequences</a>.</p>\n",
    "example": "browser.touchActions().\n    tap(element1).\n    doubleTap(element2).\n    perform();",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.touchActions",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "return",
      "description": "A new touch sequence for this instance.",
      "startingLine": 90,
      "typeExpression": "!webdriver.TouchSequence",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.TouchSequence",
        "nullable": false
      },
      "typeList": [
        "webdriver.TouchSequence"
      ]
    },
    "returnString": "&#33;[webdriver.TouchSequence](http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/index_exports_TouchSequence.html)"
  },
  {
    "description": "<p>Schedules a command to execute JavaScript in the context of the currently\nselected frame or window. The script fragment will be executed as the body\nof an anonymous function. If the script is provided as a function object,\nthat function will be converted to a string for injection into the target\nwindow.</p>\n<p>Any arguments provided in addition to the script will be included as script\narguments and may be referenced using the <code ng-non-bindable>arguments</code> object.\nArguments may be a boolean, number, string, or WebElement.\nArrays and objects may also be used as script arguments as long as each item\nadheres to the types previously mentioned.</p>\n<p>The script may refer to any variables accessible from the current window.\nFurthermore, the script will execute in the window&#39;s context, thus\n<code ng-non-bindable>document</code> may be used to refer to the current document. Any local\nvariables will not be available once the script has finished executing,\nthough global variables will persist.</p>\n<p>If the script has a return value (i.e. if the script contains a return\nstatement), then the following steps will be taken for resolving this\nfunctions return value:</p>\n<ul>\n<li>For a HTML element, the value will resolve to a WebElement</li>\n<li>Null and undefined return values will resolve to null</li></li>\n<li>Booleans, numbers, and strings will resolve as is</li></li>\n<li>Functions will resolve to their string representation</li></li>\n<li>For arrays and objects, each member item will be converted according to\n  the rules above</li>\n</ul>\n",
    "example": "var el = element(by.module('header'));\nvar tag = browser.executeScript('return arguments[0].tagName', el);\nexpect(tag).toEqual('h1');",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.executeScript",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The script to execute.",
        "startingLine": 129,
        "typeExpression": "!(string|Function)",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "FunctionType",
              "params": []
            }
          ],
          "nullable": false
        },
        "typeList": [
          "string",
          "function()"
        ],
        "name": "script",
        "paramString": "!(string&#124;Function)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The arguments to pass to the script.",
        "startingLine": 130,
        "typeExpression": "...*",
        "type": {
          "type": "AllLiteral",
          "repeatable": true
        },
        "typeList": [
          "*"
        ],
        "name": "var_args",
        "paramString": "...*"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "return",
      "description": "A promise that will resolve to the scripts return value.",
      "startingLine": 131,
      "typeExpression": "!promise.Promise<T>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "T"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!promise.Promise<T>"
      ]
    },
    "returnString": "!promise.Promise&lt;T&gt;"
  },
  {
    "description": "<p>Schedules a command to execute asynchronous JavaScript in the context of the\ncurrently selected frame or window. The script fragment will be executed as\nthe body of an anonymous function. If the script is provided as a function\nobject, that function will be converted to a string for injection into the\ntarget window.</p>\n<p>Any arguments provided in addition to the script will be included as script\narguments and may be referenced using the <code ng-non-bindable>arguments</code> object.\nArguments may be a boolean, number, string, or <code ng-non-bindable>WebElement</code>.\nArrays and objects may also be used as script arguments as long as each item\nadheres to the types previously mentioned.</p>\n<p>Unlike executing synchronous JavaScript with [<code ng-non-bindable>#executeScript</code>](webdriver.WebDriver.prototype.executeScript),\nscripts executed with this function must explicitly signal they are finished\nby invoking the provided callback. This callback will always be injected\ninto the executed function as the last argument, and thus may be referenced\nwith <code ng-non-bindable>arguments[arguments.length - 1]</code>. The following steps will be\ntaken for resolving this functions return value against the first argument\nto the script&#39;s callback function:</p>\n<ul>\n<li>For a HTML element, the value will resolve to a\n  <code ng-non-bindable>WebElement</code></li>\n<li>Null and undefined return values will resolve to null</li>\n<li>Booleans, numbers, and strings will resolve as is</li>\n<li>Functions will resolve to their string representation</li>\n<li>For arrays and objects, each member item will be converted according to\n  the rules above</li>\n</ul>\n",
    "example": "// Example 1\n// Performing a sleep that is synchronized with the currently selected window\nvar start = new Date().getTime();\nbrowser.executeAsyncScript(\n    'window.setTimeout(arguments[arguments.length - 1], 500);').\n    then(function() {\n      console.log(\n          'Elapsed time: ' + (new Date().getTime() - start) + ' ms');\n    });\n\n// Example 2\n// Synchronizing a test with an AJAX application:\nvar button = element(by.id('compose-button'));\nbutton.click();\nbrowser.executeAsyncScript(\n    'var callback = arguments[arguments.length - 1];' +\n    'mailClient.getComposeWindowWidget().onload(callback);');\nbrowser.switchTo().frame('composeWidget');\nelement(by.id('to')).sendKeys('dog@example.com');\n\n// Example 3\n// Injecting a XMLHttpRequest and waiting for the result.  In this example,\n// the inject script is specified with a function literal. When using this\n// format, the function is converted to a string for injection, so it should\n// not reference any symbols not defined in the scope of the page under test.\nbrowser.executeAsyncScript(function() {\n  var callback = arguments[arguments.length - 1];\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"GET\", \"/resource/data.json\", true);\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState == 4) {\n      callback(xhr.responseText);\n    }\n  };\n  xhr.send('');\n}).then(function(str) {\n  console.log(JSON.parse(str)['food']);\n});",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.executeAsyncScript",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The script to execute.",
        "startingLine": 206,
        "typeExpression": "!(string|Function)",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "FunctionType",
              "params": []
            }
          ],
          "nullable": false
        },
        "typeList": [
          "string",
          "function()"
        ],
        "name": "script",
        "paramString": "!(string&#124;Function)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The arguments to pass to the script.",
        "startingLine": 207,
        "typeExpression": "...*",
        "type": {
          "type": "AllLiteral",
          "repeatable": true
        },
        "typeList": [
          "*"
        ],
        "name": "var_args",
        "paramString": "...*"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "return",
      "description": "A promise that will resolve to the scripts return value.",
      "startingLine": 208,
      "typeExpression": "!promise.Promise<T>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "T"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!promise.Promise<T>"
      ]
    },
    "returnString": "!promise.Promise&lt;T&gt;"
  },
  {
    "description": "<p>Schedules a command to execute a custom function within the context of\nwebdriver&#39;s control flow.</p>\n<p>Most webdriver actions are asynchronous, but the control flow makes sure that\ncommands are executed in the order they were received.  By running your\nfunction in the control flow, you can ensure that it is executed before/after\nother webdriver actions.  Additionally, Protractor will wait until the\ncontrol flow is empty before deeming a test finished.</p>\n",
    "example": "var logText = function(el) {\n  return el.getText().then((text) => {\n    console.log(text);\n  });\n};\nvar counter = element(by.id('counter'));\nvar button = element(by.id('button'));\n// Use `browser.call()` to make sure `logText` is run before and after\n// `button.click()`\nbrowser.call(logText, counter);\nbutton.click();\nbrowser.call(logText, counter);",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.call",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The function to execute.",
        "startingLine": 238,
        "typeExpression": "function(...): (T|promise.Promise<T>)",
        "type": {
          "type": "FunctionType",
          "params": [
            ""
          ],
          "result": {
            "type": "TypeUnion",
            "elements": [
              {
                "type": "NameExpression",
                "name": "T"
              },
              {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "promise.Promise"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "T"
                  }
                ]
              }
            ]
          }
        },
        "typeList": [
          "function(...): (T|promise.Promise<T>)"
        ],
        "name": "fn",
        "paramString": "function(...): (T&#124;promise.Promise&lt;T&gt;)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The object in whose scope to execute the function (i.e. the `this` object for the function).",
        "startingLine": 240,
        "typeExpression": "Object=",
        "type": {
          "type": "NameExpression",
          "name": "Object",
          "optional": true
        },
        "typeList": [
          "Object"
        ],
        "optional": true,
        "name": "opt_scope",
        "paramString": "Object="
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Any arguments to pass to the function.  If any of the arguments are promised, webdriver will wait for these promised to resolve and pass the resulting value onto the function.",
        "startingLine": 242,
        "typeExpression": "...*",
        "type": {
          "type": "AllLiteral",
          "repeatable": true
        },
        "typeList": [
          "*"
        ],
        "name": "var_args",
        "paramString": "...*"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "return",
      "description": "A promise that will be resolved with the function's result.",
      "startingLine": 245,
      "typeExpression": "!promise.Promise<T>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "T"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!promise.Promise<T>"
      ]
    },
    "returnString": "!promise.Promise&lt;T&gt;"
  },
  {
    "description": "<p>Schedules a command to wait for a condition to hold or <code ng-non-bindable>promise</code> to be resolved.</p>\n<p>This function blocks WebDriver&#39;s control flow, not the javascript runtime.\nIt will only delay future webdriver commands from being executed (e.g. it\nwill cause Protractor to wait before sending future commands to the selenium\nserver), and only when the webdriver control flow is enabled.</p>\n<p>This function returnes a promise, which can be used if you need to block\njavascript execution and not just the control flow.</p>\n<p>See also <code ng-non-bindable>ExpectedConditions</code></p>\n<p><em>Example:</em> Suppose you have a function, <code>startTestServer</code>, that returns a\npromise for when a server is ready for requests. You can block a <code>WebDriver</code>\nclient on this promise with:</p>\n",
    "example": "var started = startTestServer();\nbrowser.wait(started, 5 * 1000, 'Server should start within 5 seconds');\nbrowser.get(getServerUrl());",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.wait",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The condition to wait on, defined as a promise, condition object, or  a function to evaluate as a condition.",
        "startingLine": 274,
        "typeExpression": "!(webdriver.promise.Promise<T>|\n          webdriver.until.Condition<T>|\n          function(!webdriver.WebDriver): T)",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "webdriver.promise.Promise"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "T"
                }
              ]
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "webdriver.until.Condition"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "T"
                }
              ]
            },
            {
              "type": "FunctionType",
              "params": [
                {
                  "type": "NameExpression",
                  "name": "webdriver.WebDriver",
                  "nullable": false
                }
              ],
              "result": {
                "type": "NameExpression",
                "name": "T"
              }
            }
          ],
          "nullable": false
        },
        "typeList": [
          "webdriver.promise.Promise.<T>",
          "webdriver.until.Condition.<T>",
          "function(!webdriver.WebDriver): T"
        ],
        "name": "condition",
        "paramString": "!(webdriver.promise.Promise&lt;T&gt;&#124;\n          webdriver.until.Condition&lt;T&gt;&#124;\n          function(!webdriver.WebDriver): T)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "How long to wait for the condition to be true. Will default 30 seconds, or to the jasmineNodeOpts.defaultTimeoutInterval in your protractor.conf.js file.",
        "startingLine": 279,
        "typeExpression": "number=",
        "type": {
          "type": "NameExpression",
          "name": "number",
          "optional": true
        },
        "typeList": [
          "number"
        ],
        "optional": true,
        "name": "opt_timeout",
        "paramString": "number="
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "An optional message to use if the wait times out.",
        "startingLine": 280,
        "typeExpression": "string=",
        "type": {
          "type": "NameExpression",
          "name": "string",
          "optional": true
        },
        "typeList": [
          "string"
        ],
        "optional": true,
        "name": "opt_message",
        "paramString": "string="
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be fulfilled with the first truthy value returned by the condition function, or rejected if the condition times out.",
      "startingLine": 282,
      "typeExpression": "!webdriver.promise.Promise<T>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "T"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise<T>"
      ]
    },
    "returnString": "!webdriver.promise.Promise&lt;T&gt;"
  },
  {
    "description": "<p>Schedules a command to make the driver sleep for the given amount of time.</p>\n",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.sleep",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The amount of time, in milliseconds, to sleep.",
        "startingLine": 290,
        "typeExpression": "number",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "typeList": [
          "number"
        ],
        "name": "ms",
        "paramString": "number"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved when the sleep has finished.",
      "startingLine": 291,
      "typeExpression": "!webdriver.promise.Promise.<void>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "void",
            "reservedWord": true
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<void>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;void&gt;"
  },
  {
    "description": "<p>Schedules a command to retrieve the current page&#39;s source. The page source\nreturned is a representation of the underlying DOM: do not expect it to be\nformatted or escaped in the same way as the response sent from the web\nserver.</p>\n",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.getPageSource",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "return",
      "description": "A promise that will be resolved with the current page source.",
      "startingLine": 301,
      "typeExpression": "!promise.Promise<string>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "string"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!promise.Promise<string>"
      ]
    },
    "returnString": "!promise.Promise&lt;string&gt;"
  },
  {
    "description": "<p>Schedules a command to close the current window.</p>\n",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.close",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "return",
      "description": "A promise that will be resolved when this command has completed.",
      "startingLine": 308,
      "typeExpression": "!promise.Promise<void>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "void",
            "reservedWord": true
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!promise.Promise<void>"
      ]
    },
    "returnString": "!promise.Promise&lt;void&gt;"
  },
  {
    "description": "<p>Schedules a command to retrieve the URL of the current page.</p>\n",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.getCurrentUrl",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved with the current URL.",
      "startingLine": 315,
      "typeExpression": "!webdriver.promise.Promise.<string>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "string"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<string>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;string&gt;"
  },
  {
    "description": "<p>Schedules a command to retrieve the current page&#39;s title.</p>\n",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.getTitle",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved with the current page's title.",
      "startingLine": 322,
      "typeExpression": "!webdriver.promise.Promise.<string>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "string"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<string>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;string&gt;"
  },
  {
    "description": "<p>Schedule a command to take a screenshot. The driver makes a best effort to\nreturn a screenshot of the following, in order of preference:</p>\n<ol>\n  <li>Entire page\n  <li>Current window\n  <li>Visible portion of the current frame\n  <li>The screenshot of the entire display containing the browser\n</ol>",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.takeScreenshot",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved to the screenshot as a base-64 encoded PNG.",
      "startingLine": 337,
      "typeExpression": "!webdriver.promise.Promise.<string>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "string"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<string>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;string&gt;"
  },
  {
    "description": "<p>Used to switch WebDriver&#39;s focus to a frame or window (e.g. an alert, an\niframe, another window).</p>\n<p>See <a href=\"http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/webdriver_exports_TargetLocator.html\">WebDriver&#39;s TargetLocator Docs</a>\nfor more information.</p>\n",
    "example": "browser.switchTo().frame(element(by.tagName('iframe')).getWebElement());",
    "fileName": "webdriver",
    "name": "webdriver.WebDriver.prototype.switchTo",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "return",
      "description": "The target locator interface for this instance.",
      "startingLine": 352,
      "typeExpression": "!TargetLocator",
      "type": {
        "type": "NameExpression",
        "name": "TargetLocator",
        "nullable": false
      },
      "typeList": [
        "TargetLocator"
      ]
    },
    "returnString": "!TargetLocator"
  },
  {
    "description": "<p>Protractor&#39;s ElementFinders are wrappers for selenium-webdriver WebElement.\nA full list of all functions available on WebElement can be found\nin the selenium-webdriver\n<a href=\"http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/webdriver_exports_WebElement.html\">documentation</a>.</p>\n",
    "fileName": "webdriver",
    "name": "webdriver.WebElement",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The webdriver driver or the parent WebDriver instance for this element.",
        "startingLine": 371,
        "typeExpression": "!webdriver.WebDriver",
        "type": {
          "type": "NameExpression",
          "name": "webdriver.WebDriver",
          "nullable": false
        },
        "typeList": [
          "webdriver.WebDriver"
        ],
        "name": "driver",
        "paramString": "&#33;[webdriver.WebDriver](webdriver.WebDriver)"
      },
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The server-assigned opaque ID for the underlying DOM element.",
        "startingLine": 373,
        "typeExpression": "!(webdriver.promise.Promise.<webdriver.WebElement.Id>|\n          webdriver.WebElement.Id)",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "webdriver.promise.Promise"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "webdriver.WebElement.Id"
                }
              ]
            },
            {
              "type": "NameExpression",
              "name": "webdriver.WebElement.Id"
            }
          ],
          "nullable": false
        },
        "typeList": [
          "webdriver.promise.Promise.<webdriver.WebElement.Id>",
          "webdriver.WebElement.Id"
        ],
        "name": "id",
        "paramString": "!(webdriver.promise.Promise.&lt;webdriver.WebElement.Id&gt;&#124;\n          webdriver.WebElement.Id)"
      }
    ],
    "returnString": ""
  },
  {
    "description": "<p>Gets the parent web element of this web element.</p>\n",
    "example": "// Using getDriver to find the parent web element to find the cat li\nvar liDog = element(by.css('.dog')).getWebElement();\nvar liCat = liDog.getDriver().findElement(by.css('.cat'));",
    "fileName": "webdriver",
    "htmlView": "&lt;ul class=&quot;pet&quot;&gt;\n &lt;li class=&quot;dog&quot;&gt;Dog&lt;/li&gt;\n &lt;li class=&quot;cat&quot;&gt;Cat&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "webdriver.WebElement.prototype.getDriver",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "The parent driver for this instance.",
      "startingLine": 394,
      "typeExpression": "!webdriver.WebDriver",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.WebDriver",
        "nullable": false
      },
      "typeList": [
        "webdriver.WebDriver"
      ]
    },
    "returnString": "&#33;[webdriver.WebDriver](webdriver.WebDriver)",
    "view": "<ul class=\"pet\">\n <li class=\"dog\">Dog</li>\n <li class=\"cat\">Cat</li>\n</ul>"
  },
  {
    "description": "<p>Gets the WebDriver ID string representation for this web element.</p>\n<br />See [<code ng-non-bindable>https:&#x2F;&#x2F;github.com&#x2F;SeleniumHQ&#x2F;selenium&#x2F;wiki&#x2F;JsonWireProtocol</code>](https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol)",
    "example": "// returns the dog web element\nvar dog = element(by.css('.dog')).getWebElement();\nexpect(dog.getId()).not.toBe(undefined);",
    "fileName": "webdriver",
    "htmlView": "&lt;ul class=&quot;pet&quot;&gt;\n  &lt;li class=&quot;dog&quot;&gt;Dog&lt;/li&gt;\n  &lt;li class=&quot;cat&quot;&gt;Cat&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "webdriver.WebElement.prototype.getId",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that resolves to this element's JSON representation as defined by the WebDriver wire protocol.",
      "startingLine": 413,
      "typeExpression": "!webdriver.promise.Promise.<webdriver.WebElement.Id>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "webdriver.WebElement.Id"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<webdriver.WebElement.Id>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;webdriver.WebElement.Id&gt;",
    "view": "<ul class=\"pet\">\n  <li class=\"dog\">Dog</li>\n  <li class=\"cat\">Cat</li>\n</ul>"
  },
  {
    "description": "<p>Use [<code ng-non-bindable>ElementFinder.prototype.element</code>](ElementFinder.prototype.element) instead</p>\n<br />See [<code ng-non-bindable>ElementFinder.prototype.element</code>](ElementFinder.prototype.element)",
    "fileName": "webdriver",
    "name": "webdriver.WebElement.prototype.findElement",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "",
        "startingLine": 425,
        "typeExpression": "webdriver.Locator",
        "type": {
          "type": "NameExpression",
          "name": "webdriver.Locator"
        },
        "typeList": [
          "webdriver.Locator"
        ],
        "name": "subLocator",
        "paramString": "webdriver.Locator"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 427,
      "typeExpression": "!webdriver.WebElement",
      "type": {
        "type": "NameExpression",
        "name": "webdriver.WebElement",
        "nullable": false
      },
      "typeList": [
        "webdriver.WebElement"
      ]
    },
    "returnString": "&#33;[webdriver.WebElement](webdriver.WebElement)"
  },
  {
    "description": "<p>Schedules a command to click on this element.</p>\n",
    "example": "// Clicks on the web link\nelement(by.partialLinkText('Doge')).click();",
    "fileName": "webdriver",
    "htmlView": "&lt;ul&gt;\n  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Doge_(meme)&quot;&gt;Doge meme&lt;/a&gt;&lt;/li&gt;\n  &lt;li&gt;Cat&lt;/li&gt;\n&lt;/ul&gt;",
    "name": "webdriver.WebElement.prototype.click",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved when the click command has completed.",
      "startingLine": 445,
      "typeExpression": "!webdriver.promise.Promise.<void>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "void",
            "reservedWord": true
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<void>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;void&gt;",
    "view": "<ul>\n  <li><a href=\"https://en.wikipedia.org/wiki/Doge_(meme)\">Doge meme</a></li>\n  <li>Cat</li>\n</ul>"
  },
  {
    "description": "<p>Schedules a command to type a sequence on the DOM element represented by this\ninstance.</p>\n<p>Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is\nprocessed in the keysequence, that key state is toggled until one of the\nfollowing occurs:</p>\n<ul>\n<li>The modifier key is encountered again in the sequence. At this point the\nstate of the key is toggled (along with the appropriate keyup/down events).</li>\n<li><p>The <code ng-non-bindable>webdriver.Key.NULL</code> key is encountered in the sequence. When\nthis key is encountered, all modifier keys current in the down state are\nreleased (with accompanying keyup events). The NULL key can be used to\nsimulate common keyboard shortcuts:</p>\n<pre><code>  element.sendKeys(&quot;text was&quot;,\n                   protractor.Key.CONTROL, &quot;a&quot;, protractor.Key.NULL,\n                   &quot;now text is&quot;);\n  // Alternatively:\n  element.sendKeys(&quot;text was&quot;,\n                   protractor.Key.chord(protractor.Key.CONTROL, &quot;a&quot;),\n                   &quot;now text is&quot;);\n</code></pre></li>\n<li><p>The end of the keysequence is encountered. When there are no more keys\nto type, all depressed modifier keys are released (with accompanying keyup\nevents).</p>\n</li>\n</ul>\n<p>If this element is a file input (<code ng-non-bindable>&lt;input type=\"file\"&gt;</code>), the\nspecified key sequence should specify the path to the file to attach to\nthe element. This is analgous to the user clicking &quot;Browse...&quot; and entering\nthe path into the file select dialog.</p>\n<pre><code>var form = driver.findElement(By.css(&#39;form&#39;));\nvar element = form.findElement(By.css(&#39;input[type=file]&#39;));\nelement.sendKeys(&#39;/path/to/file.txt&#39;);\nform.submit();\n</code></pre><p>For uploads to function correctly, the entered path must reference a file\non the <em>browser&#39;s</em> machine, not the local machine running this script. When\nrunning against a remote Selenium server, a <code ng-non-bindable>webdriver.FileDetector</code>\nmay be used to transparently copy files to the remote machine before\nattempting to upload them in the browser.</p>\n<p><strong>Note:</strong> On browsers where native keyboard events are not supported\n(e.g. Firefox on OS X), key events will be synthesized. Special\npunctionation keys will be synthesized according to a standard QWERTY en-us\nkeyboard layout.</p>\n",
    "fileName": "webdriver",
    "name": "webdriver.WebElement.prototype.sendKeys",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The sequence of keys to type. All arguments will be joined into a single sequence.",
        "startingLine": 499,
        "typeExpression": "...(string|!webdriver.promise.Promise<string>)",
        "type": {
          "type": "TypeUnion",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "webdriver.promise.Promise"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "string"
                }
              ],
              "nullable": false
            }
          ],
          "repeatable": true
        },
        "typeList": [
          "string",
          "!webdriver.promise.Promise.<string>"
        ],
        "name": "var_args",
        "paramString": "...(string&#124;!webdriver.promise.Promise&lt;string&gt;)"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved when all keys have been typed.",
      "startingLine": 501,
      "typeExpression": "!webdriver.promise.Promise.<void>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "void",
            "reservedWord": true
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<void>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;void&gt;"
  },
  {
    "description": "<p>Gets the tag/node name of this element.</p>\n",
    "example": "expect(element(by.binding('person.name')).getTagName()).toBe('span');",
    "fileName": "webdriver",
    "htmlView": "&lt;span&gt;{{person.name}}&lt;/span&gt;",
    "name": "webdriver.WebElement.prototype.getTagName",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved with the element's tag name.",
      "startingLine": 516,
      "typeExpression": "!webdriver.promise.Promise.<string>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "string"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<string>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;string&gt;",
    "view": "<span>{{person.name}}</span>"
  },
  {
    "description": "<p>Gets the computed style of an element. If the element inherits the named\nstyle from its parent, the parent will be queried for its value. Where\npossible, color values will be converted to their hex representation (e.g.</p>\n<p>#00ff00 instead of rgb(0, 255, 0)).</p>\n<p><em>Warning:</em> the value returned will be as the browser interprets it, so\nit may be tricky to form a proper assertion.</p>\n",
    "example": "expect(element(by.binding('person.name')).getCssValue('color')).toBe('#000000');",
    "fileName": "webdriver",
    "htmlView": "&lt;span style='color: #000000'&gt;{{person.name}}&lt;/span&gt;",
    "name": "webdriver.WebElement.prototype.getCssValue",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The name of the CSS style property to look up.",
        "startingLine": 537,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "cssStyleProperty",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved with the requested CSS value.",
      "startingLine": 539,
      "typeExpression": "!webdriver.promise.Promise.<string>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "string"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<string>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;string&gt;",
    "view": "<span style='color: #000000'>{{person.name}}</span>"
  },
  {
    "description": "<p>Schedules a command to query for the value of the given attribute of the\nelement. Will return the current value, even if it has been modified after\nthe page has been loaded. More exactly, this method will return the value of\nthe given attribute, unless that attribute is not present, in which case the\nvalue of the property with the same name is returned. If neither value is\nset, null is returned (for example, the &quot;value&quot; property of a textarea\nelement). The &quot;style&quot; attribute is converted as best can be to a\ntext representation with a trailing semi-colon. The following are deemed to\nbe &quot;boolean&quot; attributes and will return either &quot;true&quot; or null:</p>\n<p>async, autofocus, autoplay, checked, compact, complete, controls, declare,\ndefaultchecked, defaultselected, defer, disabled, draggable, ended,\nformnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,\nloop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,\npaused, pubdate, readonly, required, reversed, scoped, seamless, seeking,\nselected, spellcheck, truespeed, willvalidate</p>\n<p>Finally, the following commonly mis-capitalized attribute/property names\nare evaluated as expected:</p>\n<ul>\n<li>&quot;class&quot;</li>\n<li>&quot;readonly&quot;</li>\n</ul>\n",
    "example": "var foo = element(by.id('foo'));\nexpect(foo.getAttribute('class')).toEqual('bar');",
    "fileName": "webdriver",
    "htmlView": "&lt;div id=&quot;foo&quot; class=&quot;bar&quot;&gt;&lt;/div&gt;",
    "name": "webdriver.WebElement.prototype.getAttribute",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "The name of the attribute to query.",
        "startingLine": 576,
        "typeExpression": "string",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "typeList": [
          "string"
        ],
        "name": "attributeName",
        "paramString": "string"
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved with the attribute's value. The returned value will always be either a string or null.",
      "startingLine": 577,
      "typeExpression": "!webdriver.promise.Promise.<?string>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "string",
            "nullable": true
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<?string>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;?string&gt;",
    "view": "<div id=\"foo\" class=\"bar\"></div>"
  },
  {
    "description": "<p>Get the visible innerText of this element, including sub-elements, without\nany leading or trailing whitespace. Visible elements are not hidden by CSS.</p>\n",
    "example": "var foo = element(by.id('foo'));\nexpect(foo.getText()).toEqual('Inner text');",
    "fileName": "webdriver",
    "htmlView": "&lt;div id=&quot;foo&quot; class=&quot;bar&quot;&gt;Inner text&lt;/div&gt;",
    "name": "webdriver.WebElement.prototype.getText",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved with the element's visible text.",
      "startingLine": 595,
      "typeExpression": "!webdriver.promise.Promise.<string>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "string"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<string>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;string&gt;",
    "view": "<div id=\"foo\" class=\"bar\">Inner text</div>"
  },
  {
    "description": "<p>Schedules a command to compute the size of this element&#39;s bounding box, in\npixels.</p>\n",
    "example": "var foo = element(by.id('foo'));\nexpect(foo.getSize()).toEqual(jasmine.objectContaining({\n width: 50,\n height: 20\n});",
    "fileName": "webdriver",
    "htmlView": "&lt;div id=&quot;foo&quot; style=&quot;width:50px; height: 20px&quot;&gt;\n  Inner text\n&lt;/div&gt;",
    "name": "webdriver.WebElement.prototype.getSize",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved with the element's size as a <code ng-non-bindable>{width:number, height:number</code>} object.",
      "startingLine": 617,
      "typeExpression": "!webdriver.promise.Promise.<{width: number, height: number}>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "RecordType",
            "fields": [
              {
                "type": "FieldType",
                "key": {
                  "type": "NameExpression",
                  "name": "width"
                },
                "value": {
                  "type": "NameExpression",
                  "name": "number"
                }
              },
              {
                "type": "FieldType",
                "key": {
                  "type": "NameExpression",
                  "name": "height"
                },
                "value": {
                  "type": "NameExpression",
                  "name": "number"
                }
              }
            ]
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<{width: number, height: number}>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;{width: number, height: number}&gt;",
    "view": "<div id=\"foo\" style=\"width:50px; height: 20px\">\n  Inner text\n</div>"
  },
  {
    "description": "<p>Schedules a command to compute the location of this element in page space.</p>\n",
    "example": "var foo = element(by.id('foo'));\nexpect(foo.getLocation()).toEqual(jasmine.objectContaining({\n x: 15,\n y: 20\n});",
    "fileName": "webdriver",
    "htmlView": "&lt;div id=&quot;foo&quot; style=&quot;position: absolute; top:20px; left: 15px&quot;&gt;\n  Inner text\n&lt;/div&gt;",
    "name": "webdriver.WebElement.prototype.getLocation",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved to the element's location as a <code ng-non-bindable>{x:number, y:number</code>} object.",
      "startingLine": 639,
      "typeExpression": "!webdriver.promise.Promise.<{x: number, y: number}>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "RecordType",
            "fields": [
              {
                "type": "FieldType",
                "key": {
                  "type": "NameExpression",
                  "name": "x"
                },
                "value": {
                  "type": "NameExpression",
                  "name": "number"
                }
              },
              {
                "type": "FieldType",
                "key": {
                  "type": "NameExpression",
                  "name": "y"
                },
                "value": {
                  "type": "NameExpression",
                  "name": "number"
                }
              }
            ]
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<{x: number, y: number}>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;{x: number, y: number}&gt;",
    "view": "<div id=\"foo\" style=\"position: absolute; top:20px; left: 15px\">\n  Inner text\n</div>"
  },
  {
    "description": "<p>Schedules a command to query whether the DOM element represented by this\ninstance is enabled, as dicted by the <code ng-non-bindable>disabled</code> attribute.</p>\n",
    "example": "var foo = element(by.id('foo'));\nexpect(foo.isEnabled()).toBe(false);",
    "fileName": "webdriver",
    "htmlView": "&lt;input id=&quot;foo&quot; disabled=true&gt;",
    "name": "webdriver.WebElement.prototype.isEnabled",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved with whether this element is currently enabled.",
      "startingLine": 657,
      "typeExpression": "!webdriver.promise.Promise.<boolean>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "boolean"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<boolean>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;boolean&gt;",
    "view": "<input id=\"foo\" disabled=true>"
  },
  {
    "description": "<p>Schedules a command to query whether this element is selected.</p>\n",
    "example": "var foo = element(by.id('foo'));\nexpect(foo.isSelected()).toBe(false);\nfoo.click();\nexpect(foo.isSelected()).toBe(true);",
    "fileName": "webdriver",
    "htmlView": "&lt;input id=&quot;foo&quot; type=&quot;checkbox&quot;&gt;",
    "name": "webdriver.WebElement.prototype.isSelected",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved with whether this element is currently selected.",
      "startingLine": 675,
      "typeExpression": "!webdriver.promise.Promise.<boolean>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "boolean"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<boolean>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;boolean&gt;",
    "view": "<input id=\"foo\" type=\"checkbox\">"
  },
  {
    "description": "<p>Schedules a command to submit the form containing this element (or this\nelement if it is a FORM element). This command is a no-op if the element is\nnot contained in a form.</p>\n",
    "example": "var login_form = element(by.id('login'));\nlogin_form.submit();",
    "fileName": "webdriver",
    "htmlView": "&lt;form id=&quot;login&quot;&gt;\n  &lt;input name=&quot;user&quot;&gt;\n&lt;/form&gt;",
    "name": "webdriver.WebElement.prototype.submit",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved when the form has been submitted.",
      "startingLine": 695,
      "typeExpression": "!webdriver.promise.Promise.<void>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "void",
            "reservedWord": true
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<void>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;void&gt;",
    "view": "<form id=\"login\">\n  <input name=\"user\">\n</form>"
  },
  {
    "description": "<p>Schedules a command to clear the <code ng-non-bindable>value</code> of this element. This command\nhas no effect if the underlying DOM element is neither a text INPUT element\nnor a TEXTAREA element.</p>\n",
    "example": "var foo = element(by.id('foo'));\nexpect(foo.getAttribute('value')).toEqual('Default Text');\nfoo.clear();\nexpect(foo.getAttribute('value')).toEqual('');",
    "fileName": "webdriver",
    "htmlView": "&lt;input id=&quot;foo&quot; value=&quot;Default Text&quot;&gt;",
    "name": "webdriver.WebElement.prototype.clear",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved when the element has been cleared.",
      "startingLine": 715,
      "typeExpression": "!webdriver.promise.Promise.<void>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "void",
            "reservedWord": true
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<void>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;void&gt;",
    "view": "<input id=\"foo\" value=\"Default Text\">"
  },
  {
    "description": "<p>Schedules a command to test whether this element is currently displayed.</p>\n",
    "example": "var foo = element(by.id('foo'));\nexpect(foo.isDisplayed()).toBe(false);",
    "fileName": "webdriver",
    "htmlView": "&lt;div id=&quot;foo&quot; style=&quot;visibility:hidden&quot;&gt;",
    "name": "webdriver.WebElement.prototype.isDisplayed",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved with whether this element is currently visible on the page.",
      "startingLine": 731,
      "typeExpression": "!webdriver.promise.Promise.<boolean>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "boolean"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<boolean>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;boolean&gt;",
    "view": "<div id=\"foo\" style=\"visibility:hidden\">"
  },
  {
    "description": "<p>Take a screenshot of the visible region encompassed by this element&#39;s\nbounding rectangle.</p>\n",
    "example": "function writeScreenShot(data, filename) {\n  var stream = fs.createWriteStream(filename);\n  stream.write(new Buffer(data, 'base64'));\n  stream.end();\n}\nvar foo = element(by.id('foo'));\nfoo.takeScreenshot().then((png) => {\n  writeScreenShot(png, 'foo.png');\n});\n\nNote that this is a new feature in WebDriver and may not be supported by\nyour browser's driver. It isn't yet supported in Chromedriver as of 2.21.",
    "fileName": "webdriver",
    "htmlView": "&lt;div id=&quot;foo&quot;&gt;Inner Text&lt;/div&gt;",
    "name": "webdriver.WebElement.prototype.takeScreenshot",
    "params": [
      {
        "tagDef": {
          "name": "param",
          "multi": true,
          "docProperty": "params",
          "transforms": [
            null,
            null,
            null
          ]
        },
        "tagName": "param",
        "description": "Optional argument that indicates whether the element should be scrolled into view before taking a screenshot. Defaults to false.",
        "startingLine": 758,
        "typeExpression": "boolean=",
        "type": {
          "type": "NameExpression",
          "name": "boolean",
          "optional": true
        },
        "typeList": [
          "boolean"
        ],
        "optional": true,
        "name": "opt_scroll",
        "paramString": "boolean="
      }
    ],
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "A promise that will be resolved to the screenshot as a base-64 encoded PNG.",
      "startingLine": 761,
      "typeExpression": "!webdriver.promise.Promise.<string>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "NameExpression",
            "name": "string"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<string>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;string&gt;",
    "view": "<div id=\"foo\">Inner Text</div>"
  },
  {
    "alias": "ExtendedWebDriver",
    "description": "<p>Protractor&#39;s <code>browser</code> object is a wrapper for an instance of\n<code>ExtendedWebDriver</code>, provided by <code>webdriver-js-extender</code>, which itself is\njust an instance of <code>selenium-webdriver</code>&#39;s WebDriver with some extra methods\nadded in. The <code>browser</code> object inherits all of WebDriver&#39;s and\nExtendedWebDriver&#39;s methods, but only the methods most useful to Protractor\nusers are documented here.</p>\n<p><strong><em>If you are not using an appium server, <code>browser</code> may sometimes inherit\ndirectly from a normal <code>WebDriver</code> instance, and thus not inherit any of\nthe extra methods defined by <code>webdriver-js-extender</code>.  Even when <code>browser</code>\ndoes inherit from <code>ExtendedWebDriver</code>, these extra methods will only work if\nyour server implements the Appium API.</em></strong></p>\n<p>More information about <code>webdriver-js-extender</code> can be found on the <a href=\"https://github.com/angular/webdriver-js-extender\">GitHub\nrepo</a>.</p>\n",
    "extends": "{webdriver.WebDriver}",
    "fileName": "index",
    "name": "webdriver_extensions.ExtendedWebDriver",
    "returnString": ""
  },
  {
    "description": "<p>Various appium commands, including the commands implemented by <code>wd</code>.  The\nnames may be different however, and commands which are implemented already by\n<code>selenium-webdriver</code> are not re-implemented by <code>webdriver-js-extender</code>.</p>\n<p>See the <a href=\"https://github.com/angular/webdriver-js-extender\">GitHub repo</a> for\ndetails. </p>\n",
    "fileName": "index",
    "name": "webdriver_extensions.ExtendedWebDriver.prototype.Appium_Commands",
    "returns": {
      "tagDef": {
        "name": "returns",
        "aliases": [
          "return"
        ],
        "transforms": [
          null,
          null
        ]
      },
      "tagName": "returns",
      "description": "",
      "startingLine": 44,
      "typeExpression": "!webdriver.promise.Promise.<*>",
      "type": {
        "type": "TypeApplication",
        "expression": {
          "type": "NameExpression",
          "name": "webdriver.promise.Promise"
        },
        "applications": [
          {
            "type": "AllLiteral"
          }
        ],
        "nullable": false
      },
      "typeList": [
        "!webdriver.promise.Promise.<*>"
      ]
    },
    "returnString": "!webdriver.promise.Promise.&lt;*&gt;"
  }
]
}
