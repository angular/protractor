<h1 id="the-webdriver-control-flow">The WebDriver Control Flow</h1>
<p>The <a href="https://github.com/SeleniumHQ/selenium/wiki/WebDriverJs#understanding_the_api">WebDriverJS API</a> is based on <a href="https://github.com/SeleniumHQ/selenium/wiki/WebDriverJs#promises">promises</a>,
which are managed by a <a href="https://github.com/SeleniumHQ/selenium/wiki/WebDriverJs#control-flows">control flow</a>
and adapted for <a href="http://jasmine.github.io/2.3/introduction.html">Jasmine</a>.
A short summary about how Protractor interacts with the control flow is presented below.</p>
<h2 id="disabling-the-control-flow" class="anchored"><div><a href="#{{path}}#disabling-the-control-flow">&#x1f517;</a>Disabling the Control Flow</div></h2>
<p>In the future, the control flow is being removed (see
<a href="https://github.com/SeleniumHQ/selenium/issues/2969">SeleniumHQ&#39;s github issue</a>
for details).  To disable the control flow in your tests, you can use the
<code ng-non-bindable>SELENIUM_PROMISE_MANAGER: false</code> <a href="https://github.com/angular/protractor/blob/5.4.0/lib/config.ts#L644">config option</a>.</p>
<p>Instead of the control flow, you can synchronize your commands
with promise chaining or the upcoming ES7 feature <code ng-non-bindable>async</code>/<code ng-non-bindable>await</code>.  See
<a href="https://github.com/angular/protractor/blob/5.4.0/spec/ts/"><code ng-non-bindable>/spec/ts/</code></a> for examples of tests with the control flow disabled.</p>
<p>Because <code ng-non-bindable>async</code>/<code ng-non-bindable>await</code> uses native promises, it will make the Control Flow
unreliable.  As such, if you&#39;re writing a library or plugin which needs to work
whether or not the Control Flow is enabled, you&#39;ll need to handle
synchronization using promise chaining.</p>
<h2 id="promises-and-the-control-flow" class="anchored"><div><a href="#{{path}}#promises-and-the-control-flow">&#x1f517;</a>Promises and the Control Flow</div></h2>
<p>WebDriverJS (and thus, Protractor) APIs are entirely asynchronous. All functions
return promises.</p>
<p>WebDriverJS maintains a queue of pending promises, called the control flow,
to keep execution organized. For example, consider this test:</p>
<pre><code class="lang-javascript">  it(&#39;should find an element by text input model&#39;, function() {
    browser.get(&#39;app/index.html#/form&#39;);

    var username = element(by.model(&#39;username&#39;));
    username.clear();
    username.sendKeys(&#39;Jane Doe&#39;);

    var name = element(by.binding(&#39;username&#39;));

    expect(name.getText()).toEqual(&#39;Jane Doe&#39;);

    // Point A
  });
</code></pre>
<p>At Point A, none of the tasks have executed yet. The <code ng-non-bindable>browser.get</code> call is at
the front of the control flow queue, and the <code ng-non-bindable>name.getText()</code> call is at the
back. The value of <code ng-non-bindable>name.getText()</code> at point A is an unresolved promise
object.</p>
<h2 id="protractor-adaptations" class="anchored"><div><a href="#{{path}}#protractor-adaptations">&#x1f517;</a>Protractor Adaptations</div></h2>
<p>Protractor adapts Jasmine so that each spec automatically waits until the
control flow is empty before exiting.</p>
<p>Jasmine expectations are also adapted to understand promises. That&#39;s why this
line works - the code actually adds an expectation task to the control flow,
which will run after the other tasks:</p>
<pre><code class="lang-javascript">  expect(name.getText()).toEqual(&#39;Jane Doe&#39;);
</code></pre>
<h2 id="mocha-users" class="anchored"><div><a href="#{{path}}#mocha-users">&#x1f517;</a>Mocha Users</div></h2>
<p>If you are using Mocha as your test framework, the control flow will still
automatically empty itself before each test completes. However, the <code ng-non-bindable>expect</code>
function in Mocha is <em>not</em> adapted to understand promises - that&#39;s why you&#39;ll
need to use an assertion framework such as Chai as Promised. See
<a href="#/frameworks">Choosing a Framework</a> for more information.</p>
